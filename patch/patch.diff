diff -ur CM11_loganxx/frameworks/av/include/media/stagefright/ColorConverter.h CM11_loganxxP/frameworks/av/include/media/stagefright/ColorConverter.h
--- CM11_loganxx/frameworks/av/include/media/stagefright/ColorConverter.h	2016-02-19 12:52:14.000000000 +0000
+++ CM11_loganxxP/frameworks/av/include/media/stagefright/ColorConverter.h	2016-01-08 01:53:32.000000000 +0000
@@ -78,6 +78,9 @@
 
     status_t convertCbYCrY(
             const BitmapParams &src, const BitmapParams &dst);
+			
+	status_t convertYCbYCr(
+            const BitmapParams &src, const BitmapParams &dst);		
 
     status_t convertYUV420Planar(
             const BitmapParams &src, const BitmapParams &dst);
diff -ur CM11_loganxx/frameworks/av/media/libstagefright/ACodec.cpp CM11_loganxxP/frameworks/av/media/libstagefright/ACodec.cpp
--- CM11_loganxx/frameworks/av/media/libstagefright/ACodec.cpp	2016-02-19 12:52:14.000000000 +0000
+++ CM11_loganxxP/frameworks/av/media/libstagefright/ACodec.cpp	2016-02-22 18:33:05.000000000 +0000
@@ -496,11 +496,11 @@
 
     status_t err;
     if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
-        if (mStoreMetaDataInOutputBuffers) {
-            err = allocateOutputMetaDataBuffers();
-        } else {
+    //    if (mStoreMetaDataInOutputBuffers) {
+    //        err = allocateOutputMetaDataBuffers();
+    //    } else {
             err = allocateOutputBuffersFromNativeWindow();
-        }
+    //    }
     } else {
         OMX_PARAM_PORTDEFINITIONTYPE def;
         InitOMXParams(&def);
@@ -654,11 +654,29 @@
             eHalHeight,
             eHalColorFormat);
 #else
+	
+	OMX_COLOR_FORMATTYPE HalColorFormat;
+	
+	ALOGI("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: %i", def.format.video.eColorFormat);
+	switch (def.format.video.eColorFormat) {
+		case OMX_COLOR_FormatYCbYCr:
+			ALOGI("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: OMX_COLOR_FormatYCbYCr (%i) -> (%i)", OMX_COLOR_FormatYCbYCr, (OMX_COLOR_FORMATTYPE)19);
+			def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+			ALOGI("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: OMX_COLOR_FormatYCbYCr (%i) -> (%i) -> HAL_PIXEL_FORMAT_YV12 (%i)", OMX_COLOR_FormatYCbYCr, (OMX_COLOR_FORMATTYPE)19, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;	
+		break;
+		default:
+			ALOGI("PATCH:ACodec:configureOutputBuffersFromNativeWindow def.format.video.eColorFormat: default(%i) -> HAL_PIXEL_FORMAT_YV12 (%i)", def.format.video.eColorFormat, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;	
+		break;
+	}
+	
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
-            def.format.video.eColorFormat);
+            HalColorFormat);
 #endif
 
     if (err != 0) {
@@ -1834,6 +1852,27 @@
     format.nIndex = 0;
     bool found = false;
 
+	if(format.eColorFormat == OMX_COLOR_FormatYCbYCr){
+		if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+			ALOGI("PATCH:ACodec:setVideoPortFormatType is brcm");
+			format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			status_t errs = mOMX->setParameter(mNode, OMX_IndexParamVideoPortFormat, &format, sizeof(format));
+				if (errs != OK){
+					ALOGE("PATCH:ACodec:setVideoPortFormatType setParameter failed: %d", errs);
+				}
+			ALOGI("PATCH:ACodec:setVideoPortFormatType format.eColorFormat set %i", format.eColorFormat);
+		}
+	}
+	ALOGI("PATCH:ACodec:setVideoPortFormatType End format.eColorFormat : %i", format.eColorFormat);
+	if(colorFormat == OMX_COLOR_FormatYCbYCr){
+		if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+			ALOGI("PATCH:ACodec:setVideoPortFormatType is brcm");
+			colorFormat = OMX_COLOR_FormatYUV420Planar;
+			ALOGI("PATCH:ACodec:setVideoPortFormatType colorFormat set %i", colorFormat);
+		}
+	}
+	ALOGI("PATCH:ACodec:setVideoPortFormatType End format.eColorFormat : %i", colorFormat);
+
     OMX_U32 index = 0;
     for (;;) {
         format.nIndex = index;
@@ -1875,6 +1914,17 @@
     if (!found) {
         return UNKNOWN_ERROR;
     }
+	
+	ALOGI("PATCH:ACodec:setVideoPortFormatType : %i", format.eColorFormat);
+	
+	if(format.eColorFormat == OMX_COLOR_FormatYCbYCr){
+		if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+			ALOGI("PATCH:ACodec:setVideoPortFormatType is brcm");
+			format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			ALOGI("PATCH:ACodec:setVideoPortFormatType set %i", format.eColorFormat);
+		}
+	}
+	ALOGI("PATCH:ACodec:setVideoPortFormatType end : %i", format.eColorFormat);
 
     status_t err = mOMX->setParameter(
             mNode, OMX_IndexParamVideoPortFormat,
@@ -1892,9 +1942,25 @@
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamVideoPortFormat,
             &format, sizeof(format));
+	
+	ALOGI("PATCH:ACodec:setSupportedOutputFormat : %i", format.eColorFormat);
+	
     CHECK_EQ(err, (status_t)OK);
     CHECK_EQ((int)format.eCompressionFormat, (int)OMX_VIDEO_CodingUnused);
 
+	if(format.eColorFormat == OMX_COLOR_FormatYCbYCr){
+		if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+			ALOGI("PATCH:ACodec:setSupportedOutputFormat is brcm");
+			format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			status_t errs = mOMX->setParameter(mNode, OMX_IndexParamVideoPortFormat, &format, sizeof(format));
+				if (errs != OK){
+					ALOGE("PATCH:ACodec:setSupportedOutputFormat setParameter failed: %d", errs);
+				}
+			ALOGI("PATCH:ACodec:setSupportedOutputFormat format.eColorFormat set %i", format.eColorFormat);
+		}
+	}
+	ALOGI("PATCH:ACodec:setSupportedOutputFormat end : %i", format.eColorFormat);
+	
     return mOMX->setParameter(
             mNode, OMX_IndexParamVideoPortFormat,
             &format, sizeof(format));
@@ -2589,9 +2655,24 @@
 
     CHECK_EQ(err, (status_t)OK);
 
+	ALOGI("PATCH:ACodec:setVideoFormatOnPort: %i", def.format.video.eColorFormat);
+	
+	if(def.format.video.eColorFormat == OMX_COLOR_FormatYCbYCr){
+		if (!strncmp(mComponentName.c_str(), "OMX.brcm.", 9)){
+			ALOGI("PATCH:ACodec:setVideoFormatOnPort set %i", OMX_COLOR_FormatYUV420Planar);
+			def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			status_t errs = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+			if (errs != OK){
+				ALOGE("PATCH:ACodec:setVideoFormatOnPort setParameter failed: %d", errs);
+			}
+		}		
+	}
+	
+	ALOGI("PATCH:ACodec:setVideoFormatOnPort: %i end", def.format.video.eColorFormat);
+
     if (portIndex == kPortIndexInput) {
         // XXX Need a (much) better heuristic to compute input buffer sizes.
-        const size_t X = 64 * 1024;
+        const size_t X = 64 * 8 * 1024;
         if (def.nBufferSize < X) {
             def.nBufferSize = X;
         }

diff -ur CM11_loganxx/frameworks/av/media/libstagefright/colorconversion/SoftwareRenderer.cpp CM11_loganxxP/frameworks/av/media/libstagefright/colorconversion/SoftwareRenderer.cpp
--- CM11_loganxx/frameworks/av/media/libstagefright/colorconversion/SoftwareRenderer.cpp	2016-02-19 12:52:14.000000000 +0000
+++ CM11_loganxxP/frameworks/av/media/libstagefright/colorconversion/SoftwareRenderer.cpp	2016-02-22 18:41:23.000000000 +0000
@@ -208,8 +208,8 @@
         }
 
         for (int y = 0; y < (mCropHeight + 1) / 2; ++y) {
-            memcpy(dst_u, src_u, (mCropWidth + 1) / 2);
-            memcpy(dst_v, src_v, (mCropWidth + 1) / 2);
+			 memcpy(dst_u, src_v, (mCropWidth + 1) / 2);
+            memcpy(dst_v, src_u, (mCropWidth + 1) / 2);
 
             src_u += mWidth / 2;
             src_v += mWidth / 2;
diff -ur CM11_loganxx/frameworks/av/media/libstagefright/OMXCodec.cpp CM11_loganxxP/frameworks/av/media/libstagefright/OMXCodec.cpp
--- CM11_loganxx/frameworks/av/media/libstagefright/OMXCodec.cpp	2016-02-19 12:52:14.000000000 +0000
+++ CM11_loganxxP/frameworks/av/media/libstagefright/OMXCodec.cpp	2016-02-22 18:38:54.000000000 +0000
@@ -1799,6 +1799,19 @@
         CHECK_EQ(err, (status_t)OK);
         CHECK_EQ((int)format.eCompressionFormat, (int)OMX_VIDEO_CodingUnused);
 
+		if (format.eColorFormat == OMX_COLOR_FormatYCbYCr) {
+			ALOGI("PATCH:OMXCodec:setVideoOutputFormat: OMX_COLOR_FormatYCbYCr");
+			if (!strncmp(mComponentName, "OMX.brcm.", 9)){
+				ALOGI("PATCH:OMXCodec:setVideoOutputFormat: OMX.brcm.");
+				format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+				ALOGI("PATCH:OMXCodec:setVideoOutputFormat: OMX_COLOR_FormatYCbYCr -> OMX_COLOR_FormatYUV420Planar");
+				status_t errs = mOMX->setParameter(mNode, OMX_IndexParamVideoPortFormat, &format, sizeof(format));
+				if (errs != OK){
+					ALOGE("PATCH:OMXCodec:setVideoOutputFormat: setParameter failed: %d", errs);
+				}
+			}
+        }
+
 #if 0
         CHECK(format.eColorFormat == OMX_COLOR_FormatYUV420Planar
                || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
@@ -1866,11 +1879,11 @@
 
 #if 1
     // XXX Need a (much) better heuristic to compute input buffer sizes.
-#ifdef USE_SAMSUNG_COLORFORMAT
+//#ifdef USE_SAMSUNG_COLORFORMAT
     const size_t X = 64 * 8 * 1024;
-#else
-    const size_t X = 64 * 1024;
-#endif
+//#else
+//    const size_t X = 64 * 1024;
+//#endif
     if (def.nBufferSize < X) {
         def.nBufferSize = X;
     }
@@ -2428,11 +2441,37 @@
             def.format.video.nSliceHeight,
             eHalColorFormat);
 #else
+	
+	OMX_COLOR_FORMATTYPE HalColorFormat;
+	status_t errss;
+	
+	ALOGI("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow def.format.video.eColorFormat: %i", def.format.video.eColorFormat);
+	switch (def.format.video.eColorFormat) {
+		case OMX_COLOR_FormatYCbYCr:
+			ALOGI("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYCbYCr(%i) -> (%i)", OMX_COLOR_FormatYCbYCr, (OMX_COLOR_FORMATTYPE)19);
+			ALOGI("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYCbYCr(%i) -> HAL_PIXEL_FORMAT_YV12(%i)", OMX_COLOR_FormatYCbYCr, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+			def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			errss = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+			if (errss != OK){
+				ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow setParameter failed: %d", errss);
+			}		
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+		break;
+		case OMX_COLOR_FormatYUV420Planar:
+			ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYUV420Planar(%i) -> HAL_PIXEL_FORMAT_YV12(%i)", OMX_COLOR_FormatYUV420Planar, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+		break;
+		default:
+			ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow default(%i) -> default(%i)", def.format.video.eColorFormat, def.format.video.eColorFormat);
+			HalColorFormat = def.format.video.eColorFormat;
+		break;
+	}
+
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
-            def.format.video.eColorFormat);
+            HalColorFormat);
 #endif
 #else
     OMX_COLOR_FORMATTYPE eColorFormat;
@@ -6268,6 +6307,8 @@
 
     for (size_t c = 0; c < matchingCodecs.size(); c++) {
         const char *componentName = matchingCodecs.itemAt(c).mName.string();
+		
+		 ALOGI("PATCH:QueryCodecs: %s", componentName);
 
         results->push();
         CodecCapabilities *caps = &results->editItemAt(results->size() - 1);
@@ -6345,9 +6386,29 @@
         if (err != OK) {
             break;
         }
-        caps->mColorFormats.push(portFormat.eColorFormat);
-    }
-
+		ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE:Begin portFormat.eColorFormat = %i, componentName = %s", portFormat.eColorFormat, componentName);
+		if (portFormat.eColorFormat == OMX_COLOR_FormatYCbYCr) {
+			ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE: OMX_COLOR_FormatYCbYCr");
+			if (!strncmp(componentName, "OMX.brcm.", 9)){
+				ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE (%s)", componentName);
+				portFormat.eColorFormat	= OMX_COLOR_FormatYUV420Planar;
+				ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE portFormat.eColorFormat(%i)", portFormat.eColorFormat);
+				status_t errs = omx->setParameter(node, OMX_IndexParamVideoPortFormat, &portFormat, sizeof(portFormat));
+				if (errs != OK){
+					ALOGE("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE setParameter failed: %d", errs);
+				}
+				caps->mColorFormats.push(OMX_COLOR_FormatYUV420Planar);
+			}else{
+				ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE color is YCbYCr but not brcm (%s)", componentName);
+				caps->mColorFormats.push(portFormat.eColorFormat);
+			}
+		}else{
+			ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE color not YCbYCr (%i)", portFormat.eColorFormat);
+			caps->mColorFormats.push(portFormat.eColorFormat);
+		}
+		ALOGI("PATCH:QueryCodec->OMX_VIDEO_PARAM_PORTFORMATTYPE:End portFormat.eColorFormat = %i, componentName = %s", portFormat.eColorFormat, componentName);	
+   }
+	
     if (!isEncoder && !strncmp(mime, "video/", 6)) {
         if (omx->storeMetaDataInBuffers(
                     node, 1 /* port index */, OMX_TRUE) == OK ||
diff -ur CM11_loganxx/frameworks/base/services/java/com/android/server/power/PowerManagerService.java CM11_loganxxP/frameworks/base/services/java/com/android/server/power/PowerManagerService.java
--- CM11_loganxx/frameworks/base/services/java/com/android/server/power/PowerManagerService.java	2016-02-19 12:52:22.000000000 +0000
+++ CM11_loganxxP/frameworks/base/services/java/com/android/server/power/PowerManagerService.java	2016-02-22 18:45:44.000000000 +0000
@@ -247,6 +247,7 @@
     // Timestamp of the last call to user activity.
     private long mLastUserActivityTime;
     private long mLastUserActivityTimeNoChangeLights;
+	 private long mLastButtonActivityTime;
 
     // A bitfield that summarizes the effect of the user activity timer.
     // A zero value indicates that the user activity timer has expired.
@@ -1145,6 +1146,10 @@
                 return true;
             }
         } else {
+			 if (eventTime > mLastButtonActivityTime && (event & PowerManager.USER_ACTIVITY_EVENT_BUTTON) != 0) {
+                    mLastButtonActivityTime = eventTime;
+                    mDirty |= DIRTY_USER_ACTIVITY;
+            }
             if (eventTime > mLastUserActivityTime) {
                 mLastUserActivityTime = eventTime;
                 mDirty |= DIRTY_USER_ACTIVITY;
@@ -1735,7 +1740,7 @@
                         }
 
                         mKeyboardLight.setBrightness(mKeyboardVisible ? keyboardBrightness : 0);
-                        if (mButtonTimeout != 0 && now > mLastUserActivityTime + mButtonTimeout) {
+                        if (mButtonTimeout != 0 && now > mLastButtonActivityTime + mButtonTimeout) {
                             mButtonsLight.setBrightness(0);
                         } else {
                             mButtonsLight.setBrightness(buttonBrightness);
@@ -2666,8 +2671,9 @@
         if (reason == null) {
             reason = "";
         }
-        long duration;
-        if (reason.equals(PowerManager.REBOOT_RECOVERY)) {
+		 Log.e(TAG, "Reboot to recovery");
+		 SystemProperties.set("sys.powerctl", "reboot," + reason);
+		 Log.e(TAG, "Reboot to recovery sys.powerctl ok");
             // If we are rebooting to go into recovery, instead of
             // setting sys.powerctl directly we'll start the
             // pre-recovery service which will do some preparation for
@@ -2676,15 +2682,11 @@
             // This preparation can take more than 20 seconds if
             // there's a very large update package, so lengthen the
             // timeout.
-            SystemProperties.set("ctl.start", "pre-recovery");
-            duration = 120 * 1000L;
-        } else {
-            SystemProperties.set("sys.powerctl", "reboot," + reason);
-            duration = 20 * 1000L;
-        }
         try {
-            Thread.sleep(duration);
+			 Log.e(TAG, "Reboot to recovery sleep(20000)");
+		     Thread.sleep(20000);
         } catch (InterruptedException e) {
+			 Log.e(TAG, "Reboot to recovery interrupt");
             Thread.currentThread().interrupt();
         }
     }
diff -ur CM11_loganxx/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java CM11_loganxxP/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java
--- CM11_loganxx/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java	2016-02-19 12:52:22.000000000 +0000
+++ CM11_loganxxP/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java	2016-02-22 18:47:57.000000000 +0000
@@ -957,35 +957,11 @@
      * @hide
      */
     public static void setTelephonyProperty(String property, int index, String value) {
-        String propVal = "";
-        String p[] = null;
-        String prop = SystemProperties.get(property);
-
-        if (value == null) {
-            value = "";
-        }
-
-        if (prop != null) {
-            p = prop.split(",");
-        }
-
-        if (index < 0) return;
-
-        for (int i = 0; i < index; i++) {
-            String str = "";
-            if ((p != null) && (i < p.length)) {
-                str = p[i];
-            }
-            propVal = propVal + str + ",";
+        if (index != 0) {
+            property += "_" + index;
         }
 
-        propVal = propVal + value;
-        if (p != null) {
-            for (int i = index+1; i < p.length; i++) {
-                propVal = propVal + "," + p[i];
-            }
-        }
-        SystemProperties.set(property, propVal);
+        SystemProperties.set(property, value);
     }
 
     /**
@@ -994,16 +970,10 @@
      * @hide
      */
     public static String getTelephonyProperty(String property, int index, String defaultVal) {
-        String propVal = null;
-        String prop = SystemProperties.get(property);
-
-        if ((prop != null) && (prop.length() > 0)) {
-            String values[] = prop.split(",");
-            if ((index >= 0) && (index < values.length) && (values[index] != null)) {
-                propVal = values[index];
-            }
+        if (index != 0) {
+            property += "_" + index;
         }
-        return propVal == null ? defaultVal : propVal;
+		 return SystemProperties.get(property, defaultVal);
     }
 
     /**
diff -ur CM11_loganxx/frameworks/native/libs/gui/SensorEventQueue.cpp CM11_loganxxP/frameworks/native/libs/gui/SensorEventQueue.cpp
--- CM11_loganxx/frameworks/native/libs/gui/SensorEventQueue.cpp	2016-02-19 12:52:24.000000000 +0000
+++ CM11_loganxxP/frameworks/native/libs/gui/SensorEventQueue.cpp	2016-02-22 18:49:17.000000000 +0000
@@ -128,8 +128,12 @@
 
 status_t SensorEventQueue::enableSensor(int32_t handle, int32_t samplingPeriodUs,
                                         int maxBatchReportLatencyUs, int reservedFlags) const {
-    return mSensorEventConnection->enableDisable(handle, true, us2ns(samplingPeriodUs),
+    status_t err = mSensorEventConnection->enableDisable(handle, true, us2ns(samplingPeriodUs),
                                                  us2ns(maxBatchReportLatencyUs), reservedFlags);
+    if (err == NO_ERROR) {
+        mSensorEventConnection->setEventRate(handle, us2ns(samplingPeriodUs));
+    }
+    return err;
 }
 
 status_t SensorEventQueue::flush() const {
diff -ur CM11_loganxx/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp CM11_loganxxP/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
--- CM11_loganxx/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp	2016-02-19 12:52:24.000000000 +0000
+++ CM11_loganxxP/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp	2016-01-08 01:53:32.000000000 +0000
@@ -1234,13 +1234,18 @@
         //getLayer()->compositionType = HWC_FRAMEBUFFER;
     }
     virtual void setPlaneAlpha(uint8_t alpha) {
+	// HAWAII_HWC does not respect planeAlpha despite being v1.2
+	#ifndef HAWAII_HWC
         if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_2)) {
             getLayer()->planeAlpha = alpha;
         } else {
+	#endif	
             if (alpha < 0xFF) {
                 getLayer()->flags |= HWC_SKIP_LAYER;
             }
+	#ifndef HAWAII_HWC		
         }
+	#endif	
     }
     virtual void setDefaultState() {
         hwc_layer_1_t* const l = getLayer();
diff -ur CM11_loganxx/frameworks/native/services/surfaceflinger/Layer.cpp CM11_loganxxP/frameworks/native/services/surfaceflinger/Layer.cpp
--- CM11_loganxx/frameworks/native/services/surfaceflinger/Layer.cpp	2016-02-19 12:52:24.000000000 +0000
+++ CM11_loganxxP/frameworks/native/services/surfaceflinger/Layer.cpp	2016-02-22 18:50:11.000000000 +0000
@@ -1260,6 +1260,8 @@
 
 void Layer::updateTransformHint(const sp<const DisplayDevice>& hw) {
     uint32_t orientation = 0;
+	// HAWAII_HWC has display problem in landscape mode when transform is used
+	#ifndef HAWAII_HWC
     if (!mFlinger->mDebugDisableTransformHint) {
         // The transform hint is used to improve performance, but we can
         // only have a single transform hint, it cannot
@@ -1270,6 +1272,7 @@
             orientation = 0;
         }
     }
+	#endif
     mSurfaceFlingerConsumer->setTransformHint(orientation);
     mTransformHint = orientation;
 }
diff -ur CM11_loganxx/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp CM11_loganxxP/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
--- CM11_loganxx/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2016-02-19 12:52:24.000000000 +0000
+++ CM11_loganxxP/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2016-02-22 18:51:21.000000000 +0000
@@ -1162,6 +1162,7 @@
             sp<const DisplayDevice> hw(mDisplays[dpy]);
             const int32_t id = hw->getHwcDisplayId();
             if (id >= 0) {
+			#ifdef QCOM_HARDWARE
                 // Get the layers in the current drawying state
                 const LayerVector& layers(mDrawingState.layersSortedByZ);
                 bool freezeSurfacePresent = false;
@@ -1181,6 +1182,7 @@
                         }
                     }
                 }
+			#endif
 
                 const Vector< sp<Layer> >& currentLayers(
                     hw->getVisibleLayersSortedByZ());
@@ -1194,6 +1196,7 @@
                      */
                     const sp<Layer>& layer(currentLayers[i]);
                     layer->setPerFrameData(hw, *cur);
+			#ifdef QCOM_HARDWARE		
                     if(freezeSurfacePresent) {
                         // if freezeSurfacePresent, set ANIMATING flag
                         cur->setAnimating(true);
@@ -1218,6 +1221,7 @@
                             lastSurfaceViewLayer = layer;
                         }
                     }
+			#endif
                 }
             }
         }
@@ -3392,6 +3396,11 @@
 {
     ATRACE_CALL();
 
+	// Rotation artifact problems when useReadPixels is false
+	#ifdef HAWAII_HWC
+    useReadPixels = true;
+	#endif
+
     // get screen geometry
     const uint32_t hw_w = hw->getWidth();
     const uint32_t hw_h = hw->getHeight();
diff -ur CM11_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java CM11_loganxxP/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java
--- CM11_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java	2016-02-22 18:54:50.000000000 +0000
@@ -334,6 +334,16 @@
             case RINGING:
                 if (VDBG) Rlog.d(LOG_TAG, "setAudioMode RINGING");
                 int curAudioMode = mAudioManager.getMode();
+				// HACK: When Dual-SIM is enabled and call waiting occurs,
+                // com.android.phone.CallCommandService.setActiveSubscription
+                // will cause setAudioMode to be called, causing the audio
+                // mode to be chagned to "MODE_RINGTONE", rendering the active
+                // conversation to be inaudiable.
+                // (The setAudioMode() call does not occur without Dual-SIM.)
+                if (curAudioMode == AudioManager.MODE_IN_CALL) {
+					Rlog.d(LOG_TAG, "Skip MODE_IN_CALL -> MODE_RINGTONE (assume call waiting)");
+                    return;
+                }
                 if (curAudioMode != AudioManager.MODE_RINGTONE) {
                     // only request audio focus if the ringtone is going to be heard
                     if (mAudioManager.getStreamVolume(AudioManager.STREAM_RING) > 0
diff -ur CM11_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java CM11_loganxxP/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java
--- CM11_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2016-02-22 18:55:14.000000000 +0000
@@ -150,6 +150,7 @@
     boolean mDnsCheckDisabled;
     public DcTrackerBase mDcTracker;
     boolean mDoesRilSendMultipleCallRing;
+	boolean mDoesRilSendCallRing;
     int mCallRingContinueToken;
     int mCallRingDelay;
     public boolean mIsTheCurrentActivePhone = true;
@@ -329,6 +330,11 @@
                 TelephonyProperties.PROPERTY_RIL_SENDS_MULTIPLE_CALL_RING, true);
         Rlog.d(LOG_TAG, "mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
 
+		 // Some RIL do not even send a single RIL_UNSOL_CALL_RING
+        mDoesRilSendCallRing = SystemProperties.getBoolean(
+                "ro.telephony.call_ring", true);
+        Rlog.d(LOG_TAG, "mDoesRilSendCallRing=" + mDoesRilSendCallRing);
+		
         mCallRingDelay = SystemProperties.getInt(
                 TelephonyProperties.PROPERTY_CALL_RING_DELAY, 3000);
         Rlog.d(LOG_TAG, "mCallRingDelay=" + mCallRingDelay);
@@ -1381,6 +1387,18 @@
     protected void notifyNewRingingConnectionP(Connection cn) {
         if (!mIsVoiceCapable)
             return;
+			
+		 // Fake RIL_UNSOL_CALL_RING if the RIL doesn't send it.
+        // Note that we need the delay to prevent the request from
+        // being sent after CallTracker detects "RINGING" state, but
+        // before the correct contact-specific ringtone is queried.
+        // Otherwise, the incorrect ringtone will be used
+        if (!mDoesRilSendCallRing) {
+            int token = ++mCallRingContinueToken;
+            sendMessageDelayed(
+                    obtainMessage(EVENT_CALL_RING_CONTINUE, token, 0), mCallRingDelay);
+        }
+
         AsyncResult ar = new AsyncResult(null, cn, null);
         mNewRingingConnectionRegistrants.notifyRegistrants(ar);
     }
@@ -1522,6 +1540,7 @@
         pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
         pw.println(" mDcTracker=" + mDcTracker);
         pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
+		 pw.println(" mDoesRilSendCallRing=" + mDoesRilSendCallRing);
         pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
         pw.println(" mCallRingDelay=" + mCallRingDelay);
         pw.println(" mIsTheCurrentActivePhone=" + mIsTheCurrentActivePhone);
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java	2016-02-22 18:56:41.000000000 +0000
@@ -143,11 +143,13 @@
 
 
     //***** Events
-    private static final int EVENT_RADIO_NOT_AVAILABLE = 1;
+    private static final int EVENT_RADIO_OFF_OR_NOT_AVAILABLE = 0;
+    private static final int EVENT_RADIO_ON = 1;
     private static final int EVENT_ICC_CHANGED = 2;
     private static final int EVENT_GET_ICCID_DONE = 3;
     private static final int EVENT_UPDATE_UICC_STATUS = 4;
     private static final int EVENT_SIM_REFRESH = 5;
+	 private static final int EVENT_RADIO_NOT_AVAILABLE = 6;
 
     //***** Class Variables
     private static CardSubscriptionManager sCardSubscriptionManager;
@@ -156,6 +158,7 @@
     private CommandsInterface[] mCi;
     private MSimUiccController mUiccController;
     private int mNumPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+	 private boolean[] mRadioOn = new boolean[mNumPhones];
     private boolean[] mSubActivated = new boolean[mNumPhones];
 
     private int mUpdateUiccStatusContext = 0;
@@ -203,10 +206,13 @@
         for (int i = 0; i < mCi.length; i++) {
             // Register for Subscription ready event for both the subscriptions.
             Integer slot = new Integer(i);
+			 mCi[i].registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_NOT_AVAILABLE, slot);
             mCi[i].registerForNotAvailable(this, EVENT_RADIO_NOT_AVAILABLE, slot);
+			 mCi[i].registerForOn(this, EVENT_RADIO_ON, slot);
 
             // Register for SIM Refresh events
             mCi[i].registerForIccRefresh(this, EVENT_SIM_REFRESH, new Integer(i));
+			 mRadioOn[i] = false;
             mSubActivated[i] = false;
         }
 
@@ -231,6 +237,16 @@
     @Override
     public void handleMessage(Message msg) {
         switch(msg.what) {
+			case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
+                logd("EVENT_RADIO_OFF_OR_NOT_AVAILABLE");
+                processRadioOffOrNotAvailable((AsyncResult)msg.obj);
+                break;
+
+            case EVENT_RADIO_ON:
+                logd("EVENT_RADIO_ON");
+                processRadioOn((AsyncResult)msg.obj);
+                break;
+
             case EVENT_RADIO_NOT_AVAILABLE:
                 logd("EVENT_RADIO_NOT_AVAILABLE");
                 processRadioNotAvailable((AsyncResult)msg.obj);
@@ -279,13 +295,36 @@
             loge("processSimRefresh received without input");
         }
     }
+	
+	private void processRadioOffOrNotAvailable(AsyncResult ar) {
+        Integer cardIndex = (Integer)ar.userObj;
+
+        logd("processRadioOffOrNotAvailable on cardIndex = " + cardIndex);
+
+        if (cardIndex >= 0 && cardIndex < mRadioOn.length) {
+            mRadioOn[cardIndex] = false;
+            //If sub is deactivated then reset card info.
+            if (mSubActivated[cardIndex] == false) {
+                resetCardInfo(cardIndex);
+                //CardInfo is not valid. Inform others that card info not available.
+                notifyCardInfoNotAvailable(cardIndex,
+                        CardUnavailableReason.REASON_RADIO_UNAVAILABLE);
+                // Reset the flag card info available to false, so that
+                // next time it notifies all cards info available.
+                mAllCardsInfoAvailable = false;
+            }
+        } else {
+            logd("Invalid Index!!!");
+        }
+    }
 
     private void processRadioNotAvailable(AsyncResult ar) {
         Integer cardIndex = (Integer)ar.userObj;
 
         logd("processRadioNotAvailable on cardIndex = " + cardIndex);
 
-        if (cardIndex >= 0 && cardIndex < mNumPhones) {
+        if (cardIndex >= 0 && cardIndex < mRadioOn.length) {
+            mRadioOn[cardIndex] = false;
             //Radio unavailable comes in case of rild crash or Modem SSR.
             //reset card info in case of radio Unavailable in order to send SET_UICC later.
             resetCardInfo(cardIndex);
@@ -300,6 +339,18 @@
             logd("Invalid Index!!!");
         }
     }
+	
+	private void processRadioOn(AsyncResult ar) {
+        Integer cardIndex = (Integer)ar.userObj;
+
+        logd("processRadioOn on cardIndex = " + cardIndex);
+
+        if (cardIndex >= 0 && cardIndex < mRadioOn.length) {
+            mRadioOn[cardIndex] = true;
+        } else {
+            logd("Invalid Index!!!");
+        }
+    }
 
     /**
      * Process the ICC_CHANGED notification.
@@ -312,6 +363,10 @@
 
         if ((ar.exception == null) && (ar.result != null)) {
             Integer cardIndex = (Integer) ar.result;
+			if (!mRadioOn[cardIndex]) {
+                logd("handleIccChanged: radio not available - EXIT");
+                return;
+            }
             UiccCard uiccCard = mUiccController.getUiccCards()[cardIndex];
             UiccCard card = mUiccCardList.get(cardIndex).getUiccCard();
 
@@ -450,6 +505,11 @@
         }
 
         logd("handleGetIccIdDone: cardIndex = " + cardIndex);
+		
+		if (!mRadioOn[cardIndex]) {
+            logd("handleGetIccIdDone: radio not available - EXIT");
+            return;
+        }
 
         String iccId = null;
 
@@ -588,7 +648,8 @@
             uiccCard = cardInfo.getUiccCard();
         }
 
-        if (uiccCard == null) {
+        if (uiccCard == null || mRadioOn[cardIndex] == false) {
+            logd("onUpdateUiccStatus(): mRadioOn[" + cardIndex + "] = " + mRadioOn[cardIndex]);
             logd("onUpdateUiccStatus(): NO Card!!!!! at index : " + cardIndex);
             if (mCardSubData[cardIndex] != null) {
                 // Card is removed.
@@ -713,7 +774,7 @@
 
         // Required to notify only once!!!
         // Notify if all card info is available.
-        if (isValidCards() && !mAllCardsInfoAvailable) {
+        if (isValidCards() && !mAllCardsInfoAvailable && mRadioOn[cardIndex]) {
             mAllCardsInfoAvailable = true;
             notifyAllCardsInfoAvailable();
         }
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimCDMALTEPhone.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimCDMALTEPhone.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimCDMALTEPhone.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimCDMALTEPhone.java	2016-02-22 18:57:12.000000000 +0000
@@ -99,7 +99,6 @@
                 this, EVENT_SUBSCRIPTION_ACTIVATED, null);
         subMgr.registerForSubscriptionDeactivated(mSubscription,
                 this, EVENT_SUBSCRIPTION_DEACTIVATED, null);
-        mSubscriptionData = subMgr.getCurrentSubscription(mSubscription);
     }
 
     @Override
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimGSMPhone.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimGSMPhone.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimGSMPhone.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimGSMPhone.java	2016-02-22 18:57:23.000000000 +0000
@@ -85,7 +85,6 @@
                 this, EVENT_SUBSCRIPTION_ACTIVATED, null);
         subMgr.registerForSubscriptionDeactivated(mSubscription,
                 this, EVENT_SUBSCRIPTION_DEACTIVATED, null);
-        mSubscriptionData = subMgr.getCurrentSubscription(mSubscription);
 
         setProperties();
     }
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimUiccController.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimUiccController.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimUiccController.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimUiccController.java	2016-02-22 18:57:35.000000000 +0000
@@ -157,7 +157,6 @@
             Integer index = new Integer(i);
             mCis[i].registerForIccStatusChanged(this, EVENT_ICC_STATUS_CHANGED, index);
             // TODO remove this once modem correctly notifies the unsols
-            mCis[i].registerForAvailable(this, EVENT_ICC_STATUS_CHANGED, index);
             mCis[i].registerForOn(this, EVENT_ICC_STATUS_CHANGED, index);
             mCis[i].registerForNotAvailable(this, EVENT_RADIO_UNAVAILABLE, index);
         }
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java	2016-02-22 18:58:15.000000000 +0000
@@ -164,6 +164,7 @@
 
     private boolean[] mCardInfoAvailable = new boolean[mNumPhones];
     private boolean[] mIsNewCard = new boolean[mNumPhones];
+	private boolean[] mRadioOn = new boolean[mNumPhones];
 
     private HashMap<SubscriptionId, Subscription> mActivatePending;
     private HashMap<SubscriptionId, Subscription> mDeactivatePending;
@@ -272,6 +273,7 @@
 
             mCardInfoAvailable[i] = false;
             mIsNewCard[i] = false;
+			mRadioOn[i] = false;
         }
 
         mSubDeactivatedRegistrants = new RegistrantList[mNumPhones];
@@ -323,15 +325,21 @@
                 ar = (AsyncResult)msg.obj;
                 subId = (Integer)ar.userObj;
                 logd("EVENT_RADIO_OFF_OR_NOT_AVAILABLE on SUB: " + subId);
-                mSetSubscriptionInProgress = false;
-                mSetDdsRequired = true;
+                mRadioOn[subId] = false;
+                if (!isAllRadioOn()) {
+                    mSetSubscriptionInProgress = false;
+                    mSetDdsRequired = true;
+                }
                 break;
 
             case EVENT_RADIO_ON:
                 ar = (AsyncResult)msg.obj;
                 subId = (Integer)ar.userObj;
                 logd("EVENT_RADIO_ON on SUB: " + subId);
-                sendDefaultSubsInfo();
+                mRadioOn[subId] = true;
+                if (isAllRadioOn()) {
+                   sendDefaultSubsInfo();
+                }
                 break;
 
             case EVENT_CARD_INFO_AVAILABLE:
@@ -581,6 +589,10 @@
      * @param ar
      */
     private void processCleanupDataConnectionDone(Integer subId) {
+		if (!mRadioOn[subId]) {
+           logd("processCleanupDataConnectionDone: Radio Not Available on subId = " + subId);
+           return;
+        }
         // Cleanup data connection is done!  Start processing the
         // pending deactivate requests now.
         mDataActive = false;
@@ -598,6 +610,11 @@
         boolean isSubReady = mCurrentSubscriptions.get(sub).subReady;
         logd("processSubscriptionStatusChanged sub = " + subId
                 + " actStatus = " + actStatus);
+		
+		if (!mRadioOn[subId]) {
+           logd("processSubscriptionStatusChanged: Radio Not Available on subId = " + subId);
+           return;
+        }
 
         if ((isSubReady == true && actStatus == SUB_STATUS_ACTIVATED) ||
                 (isSubReady == false && actStatus == SUB_STATUS_DEACTIVATED)) {
@@ -661,6 +678,12 @@
         String cause = null;
         SubscriptionStatus subStatus = SubscriptionStatus.SUB_INVALID;
         Subscription currentSub = null;
+		
+		if (!mRadioOn[setSubParam.subId]) {
+           logd("processSetUiccSubscriptionDone: Radio Not Available on subId = "
+                + setSubParam.subId);
+           return;
+        }
 
         if (setSubParam.appType.equals("GLOBAL") &&
                 (setSubParam.subStatus == SubscriptionStatus.SUB_ACTIVATE)) {
@@ -1000,6 +1023,10 @@
      * Handles EVENT_ALL_CARDS_INFO_AVAILABLE.
      */
     private void processAllCardsInfoAvailable() {
+		if (!isAllRadioOn()) {
+           logd("processAllCardsInfoAvailable: Radio Not Available ");
+           return;
+        }
         int availableCards = 0;
         mAllCardsStatusAvailable = true;
 
@@ -1028,6 +1055,10 @@
      * Handles EVENT_PROCESS_AVAILABLE_CARDS
      */
     private void processAvailableCards() {
+		 if (!isAllRadioOn()) {
+           logd("processAvailableCards: Radio Not Available ");
+           return;
+        }
         if (mSetSubscriptionInProgress) {
            logd("processAvailableCards: set subscription in progress!!");
            return;
@@ -1143,6 +1174,11 @@
      */
     private void processCardInfoAvailable(AsyncResult ar) {
         Integer cardIndex = (Integer)ar.userObj;
+		
+		 if (!mRadioOn[cardIndex]) {
+           logd("processCardInfoAvailable: Radio Not Available on cardIndex = " + cardIndex);
+           return;
+        }
 
         mCardInfoAvailable[cardIndex] = true;
 
@@ -1195,6 +1231,14 @@
 
         mContext.startActivity(setSubscriptionIntent);
     }
+	
+	private boolean isAllRadioOn() {
+        boolean result = true;
+        for (boolean radioOn : mRadioOn) {
+            result = result && radioOn;
+        }
+        return result;
+    }
 
     private boolean isAllCardsInfoAvailable() {
         boolean result = true;
diff -ur CM11_loganxx/hardware/broadcom/libbt/src/userial_vendor.c CM11_loganxxP/hardware/broadcom/libbt/src/userial_vendor.c
--- CM11_loganxx/hardware/broadcom/libbt/src/userial_vendor.c	2016-02-19 12:52:26.000000000 +0000
+++ CM11_loganxxP/hardware/broadcom/libbt/src/userial_vendor.c	2016-02-22 18:59:05.000000000 +0000
@@ -182,6 +182,10 @@
     uint8_t data_bits;
     uint16_t parity;
     uint8_t stop_bits;
+	
+	#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+    int ldisc;
+	#endif
 
     vnd_userial.fd = -1;
 
@@ -252,6 +256,12 @@
     tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
 
 #if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+	 // TODO: check for breakage on tuna (Galaxy Nexus). It defines this,
+    // but does not contain the kernel code to support it.
+    // Switch to N_BRCM_HCI line disclipline for ioctl to work
+    ldisc = 25; // N_BRCM_HCI
+    ioctl(vnd_userial.fd, TIOCSETD, &ldisc);
+
     userial_ioctl_init_bt_wake(vnd_userial.fd);
 #endif
 
diff -ur CM11_loganxx/packages/apps/Settings/res/xml/multi_sim_settings.xml CM11_loganxxP/packages/apps/Settings/res/xml/multi_sim_settings.xml
--- CM11_loganxx/packages/apps/Settings/res/xml/multi_sim_settings.xml	2016-02-19 12:52:42.000000000 +0000
+++ CM11_loganxxP/packages/apps/Settings/res/xml/multi_sim_settings.xml	2016-02-22 19:00:24.000000000 +0000
@@ -31,16 +31,6 @@
 <PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:settings="http://schemas.android.com/apk/res/com.android.settings">
 
-    <PreferenceScreen
-        android:key="config_sub"
-        android:title="@string/sel_sub_title"
-        android:summary="@string/sel_sub_summary"
-        android:persistent="false">
-        <intent android:action="android.intent.action.MAIN"
-                android:targetPackage="com.android.phone"
-                android:targetClass="com.android.phone.SetSubscription" />
-    </PreferenceScreen>
-
     <CheckBoxPreference
         android:key="tune_away"
         android:title="@string/tune_away_title"
diff -ur CM11_loganxx/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java CM11_loganxxP/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java
--- CM11_loganxx/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java	2016-02-19 12:52:42.000000000 +0000
+++ CM11_loganxxP/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java	2016-02-22 19:01:44.000000000 +0000
@@ -101,7 +101,6 @@
     private ListPreference mVoice;
     private ListPreference mData;
     private ListPreference mSms;
-    private PreferenceScreen mConfigSub;
     private CharSequence[] entries; // Used for entries like Subscription1, Subscription2 ...
     private CharSequence[] entryValues; // Used for entryValues like 0, 1 ,2 ...
     private CharSequence[] summaries; // Used for Summaries like Aubscription1, Subscription2....
@@ -142,8 +141,6 @@
         mData.setOnPreferenceChangeListener(this);
         mSms = (ListPreference) findPreference(KEY_SMS);
         mSms.setOnPreferenceChangeListener(this);
-        mConfigSub = (PreferenceScreen) findPreference(KEY_CONFIG_SUB);
-        mConfigSub.getIntent().putExtra(CONFIG_SUB, true);
         mTuneAway = (CheckBoxPreference) findPreference(TUNE_AWAY);
         mTuneAway.setOnPreferenceChangeListener(this);
         mPrioritySub = (ListPreference) findPreference(PRIORITY_SUB);
@@ -230,14 +227,9 @@
         Log.d(TAG, "mIccCardCount = " + mIccCardCount);
 
         if (mIccCardCount == 0) {
-             mConfigSub.setEnabled(false);
-             mConfigSub.setSelectable(false);
              displayAlertDialog(getResources().getString(R.string.no_sim_info));
              configureMSimMenu(false);
         } else if (mIccCardCount == 1) {
-             //1 SIM card is present. Config sub must be accessible
-             mConfigSub.setEnabled(true);
-             mConfigSub.setSelectable(true);
              configureMSimMenu(false);
         } else if ( (mIccCardCount > 1) && (mIccCardCount <= MAX_SUBSCRIPTIONS) )  {
             configureMSimMenu(true);
@@ -591,11 +583,6 @@
                     }
 
                     break;
-                case EVENT_SUBSCRIPTION_ACTIVATED:
-                case EVENT_SUBSCRIPTION_DEACTIVATED:
-                    updateMultiSimEntriesForVoice();
-                    updateMultiSimEntriesForSms();
-                    break;
 
                 case EVENT_SET_VOICE_SUBSCRIPTION:
                     if (!mHasTuneAway) {
diff -ur CM11_loganxx/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java CM11_loganxxP/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java
--- CM11_loganxx/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java	2016-02-19 12:52:45.000000000 +0000
+++ CM11_loganxxP/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java	2016-02-22 19:03:14.000000000 +0000
@@ -60,6 +60,7 @@
 import android.provider.ContactsContract.CommonDataKinds;
 import android.provider.MediaStore;
 import android.provider.Settings;
+import android.telephony.MSimTelephonyManager;
 import android.telephony.PhoneNumberUtils;
 import android.text.TextUtils;
 import android.util.Log;
@@ -2693,10 +2694,15 @@
      * This is useful for implementing "HomeAsUp" capability for second-level Settings.
      */
     public static void goUpToTopLevelSetting(Activity activity) {
-        Intent intent = new Intent(activity, CallFeaturesSetting.class);
-        intent.setAction(Intent.ACTION_MAIN);
-        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
-        activity.startActivity(intent);
+         if (!MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+            // HACK: This doesn't work on multi-SIM (and we have multiple)
+            //       hierachy (MSimCallFeaturesSetting and MSimCallFeatureSubSetting)
+            //       so let just allow this to act like "back" button
+            Intent intent = new Intent(activity, CallFeaturesSetting.class);
+            intent.setAction(Intent.ACTION_MAIN);
+            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+            activity.startActivity(intent);
+        }
         activity.finish();
     }
 

commit aa496769fa9d4e49bbce4f7d275f896d817b1a96
Author: The Prezident <theprezident1@gmail.com>
Date:   Thu Apr 21 21:12:51 2016 +0530

    patch to fix video play back in browser
    
    Change-Id: I4e6f18809bc0c8a749c12bcce7de9cb985dc4792

diff --git a/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp b/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
index 1577cda..597167f 100644
--- a/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -22,10 +22,6 @@
 #include <media/stagefright/ColorConverter.h>
 #include <media/stagefright/MediaErrors.h>
 
-#ifdef MTK_HARDWARE
-#include <mtkcolorconverter/MtkColorConverter.h>
-#endif
-
 namespace android {
 
 ColorConverter::ColorConverter(
@@ -33,18 +29,11 @@ ColorConverter::ColorConverter(
     : mSrcFormat(from),
       mDstFormat(to),
       mClip(NULL) {
-#ifdef MTK_HARDWARE
-    mMtkColorConverter = new MtkColorConverter(this);
-#endif
 }
 
 ColorConverter::~ColorConverter() {
     delete[] mClip;
     mClip = NULL;
-#ifdef MTK_HARDWARE
-    delete mMtkColorConverter;
-    mMtkColorConverter = NULL;
-#endif
 }
 
 bool ColorConverter::isValid() const {
@@ -58,11 +47,6 @@ bool ColorConverter::isValid() const {
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
-#ifdef MTK_HARDWARE
-        case OMX_MTK_COLOR_FormatYV12:
-        case OMX_COLOR_FormatVendorMTKYUV:
-        case OMX_COLOR_FormatVendorMTKYUV_FCM:
-#endif
             return true;
 
         default:
@@ -119,11 +103,7 @@ status_t ColorConverter::convert(
 
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
-#ifdef MTK_HARDWARE
-            err = mMtkColorConverter->convertYUVToRGBHW(src, dst);
-#else
             err = convertYUV420Planar(src, dst);
-#endif
             break;
 
         case OMX_COLOR_FormatCbYCrY:
@@ -142,14 +122,6 @@ status_t ColorConverter::convert(
             err = convertTIYUV420PackedSemiPlanar(src, dst);
             break;
 
-#ifdef MTK_HARDWARE
-        case OMX_MTK_COLOR_FormatYV12:
-        case OMX_COLOR_FormatVendorMTKYUV:
-        case OMX_COLOR_FormatVendorMTKYUV_FCM:
-            err = mMtkColorConverter->convertYUVToRGBHW(src, dst);
-            break;
-#endif
-
         default:
         {
             CHECK(!"Should not be here. Unknown color conversion.");


project frameworks/base/
diff --git a/frameworks/base/core/java/android/os/Environment.java b/frameworks/base/core/java/android/os/Environment.java
index a3350da..a4e5fe0 100644
--- a/frameworks/base/core/java/android/os/Environment.java
+++ b/frameworks/base/core/java/android/os/Environment.java
@@ -278,6 +278,83 @@ public class Environment {
     }
 
     /**
+     * Gets an external volume that supports having external apps.
+     * If such a volume does not exist (eg. devices that do not have an SD card
+     * and do not support USB-OTG), then null is returned.
+     * @return StorageVolume object representing a volume supporting external apps.
+     * @hide
+     */
+    private static StorageVolume getExternalAppsVolume() {
+        try {
+            IMountService mountService = IMountService.Stub.asInterface(ServiceManager
+                    .getService("mount"));
+            final StorageVolume[] volumes = mountService.getVolumeList();
+            for (StorageVolume volume : volumes) {
+                if (volume.isExternalApps()) {
+                    Log.v(TAG, "Found external apps volume: " + volume.getPath());
+                    return volume;
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "couldn't talk to MountService", e);
+        }
+        return null;
+    }
+
+    /**
+     * Determine if there is a volume supporting external apps and if it's mounted.
+     * @return True if an external apps volume exists and is mounted, otherwise, false.
+     * @hide
+     */
+    public static boolean isExternalAppsAvailableAndMounted() {
+        if (getExternalAppsVolume() != null) {
+            String state = getExternalAppsVolumeState();
+
+            if (state.equals(MEDIA_MOUNTED)) {
+                final File temp = new File("/data/system/no-external-apps");
+                if (temp.exists()) {
+                    Log.v(TAG, "Application moving was explicitly disabled");
+                    return false;
+                }
+                return true;
+            }
+        } else {
+            Log.v(TAG, "External apps volume is NOT available");
+        }
+        return false;
+    }
+
+    /**
+     * Gets the current state of the external apps volume.
+     * @see #getExternalAppsVolumeDirectory()
+     * @return String containing the state of the external apps volume.
+     * @hide
+     */
+    public static String getExternalAppsVolumeState() {
+        try {
+            IMountService mountService = IMountService.Stub.asInterface(ServiceManager
+                    .getService("mount"));
+            return mountService.getVolumeState(getExternalAppsVolume().getPath());
+        } catch (RemoteException rex) {
+            Log.w(TAG, "Failed to read external SD state; assuming REMOVED: " + rex);
+            return Environment.MEDIA_REMOVED;
+        }
+    }
+
+    /**
+     * Gets the mount point/directory of the external apps volume.
+     * @return File object for the directory of the external apps volume.
+     * @hide
+     */
+    public static File getExternalAppsVolumeDirectory() {
+        StorageVolume volume = getExternalAppsVolume();
+        if (volume != null) {
+          return new File(volume.getPath());
+        }
+        return null;
+    }
+
+    /**
      * Return directory used for internal media storage, which is protected by
      * {@link android.Manifest.permission#WRITE_MEDIA_STORAGE}.
      *
diff --git a/frameworks/base/core/java/android/os/storage/StorageVolume.java b/frameworks/base/core/java/android/os/storage/StorageVolume.java
index 06565f1..1328d25 100644
--- a/frameworks/base/core/java/android/os/storage/StorageVolume.java
+++ b/frameworks/base/core/java/android/os/storage/StorageVolume.java
@@ -48,6 +48,7 @@ public class StorageVolume implements Parcelable {
     private final long mMaxFileSize;
     /** When set, indicates exclusive ownership of this volume */
     private final UserHandle mOwner;
+    private final boolean mExternalApps;
 
     private String mUuid;
     private String mUserLabel;
@@ -70,6 +71,22 @@ public class StorageVolume implements Parcelable {
         mAllowMassStorage = allowMassStorage;
         mMaxFileSize = maxFileSize;
         mOwner = owner;
+        mExternalApps = false;
+    }
+
+    public StorageVolume(File path, int descriptionId, boolean primary, boolean removable,
+            boolean emulated, int mtpReserveSpace, boolean allowMassStorage, long maxFileSize,
+            UserHandle owner, boolean externalApps) {
+        mPath = path;
+        mDescriptionId = descriptionId;
+        mPrimary = primary;
+        mRemovable = removable;
+        mEmulated = emulated;
+        mMtpReserveSpace = mtpReserveSpace;
+        mAllowMassStorage = allowMassStorage;
+        mMaxFileSize = maxFileSize;
+        mOwner = owner;
+        mExternalApps = externalApps;
     }
 
     private StorageVolume(Parcel in) {
@@ -83,6 +100,7 @@ public class StorageVolume implements Parcelable {
         mAllowMassStorage = in.readInt() != 0;
         mMaxFileSize = in.readLong();
         mOwner = in.readParcelable(null);
+        mExternalApps = in.readInt() != 0;
         mUuid = in.readString();
         mUserLabel = in.readString();
         mState = in.readString();
@@ -91,7 +109,7 @@ public class StorageVolume implements Parcelable {
     public static StorageVolume fromTemplate(StorageVolume template, File path, UserHandle owner) {
         return new StorageVolume(path, template.mDescriptionId, template.mPrimary,
                 template.mRemovable, template.mEmulated, template.mMtpReserveSpace,
-                template.mAllowMassStorage, template.mMaxFileSize, owner);
+                template.mAllowMassStorage, template.mMaxFileSize, owner, template.mExternalApps);
     }
 
     /**
@@ -143,6 +161,15 @@ public class StorageVolume implements Parcelable {
     }
 
     /**
+     * Returns true if the volume supports external apps.
+     *
+     * @return supports external apps
+     */
+    public boolean isExternalApps() {
+        return mExternalApps;
+    }
+
+    /**
      * Returns the MTP storage ID for the volume.
      * this is also used for the storage_id column in the media provider.
      *
@@ -272,6 +299,7 @@ public class StorageVolume implements Parcelable {
         pw.printPair("mAllowMassStorage", mAllowMassStorage);
         pw.printPair("mMaxFileSize", mMaxFileSize);
         pw.printPair("mOwner", mOwner);
+        pw.printPair("mExternalApps", mExternalApps);
         pw.printPair("mUuid", mUuid);
         pw.printPair("mUserLabel", mUserLabel);
         pw.printPair("mState", mState);
@@ -307,6 +335,7 @@ public class StorageVolume implements Parcelable {
         parcel.writeInt(mAllowMassStorage ? 1 : 0);
         parcel.writeLong(mMaxFileSize);
         parcel.writeParcelable(mOwner, flags);
+        parcel.writeInt(mExternalApps ? 1 : 0);
         parcel.writeString(mUuid);
         parcel.writeString(mUserLabel);
         parcel.writeString(mState);
diff --git a/frameworks/base/core/res/res/values/attrs.xml b/frameworks/base/core/res/res/values/attrs.xml
index 43f64ef..06d77ea 100644
--- a/frameworks/base/core/res/res/values/attrs.xml
+++ b/frameworks/base/core/res/res/values/attrs.xml
@@ -6008,6 +6008,8 @@
         <attr name="allowMassStorage" format="boolean" />
         <!-- maximum file size for the volume in megabytes, zero or unspecified if it is unbounded -->
         <attr name="maxFileSize" format="integer" />
+        <!-- true if volume supports external apps -->
+        <attr name="externalApps" format="boolean" />
     </declare-styleable>
 
     <declare-styleable name="SwitchPreference">
diff --git a/frameworks/base/packages/DefaultContainerService/src/com/android/defcontainer/DefaultContainerService.java b/frameworks/base/packages/DefaultContainerService/src/com/android/defcontainer/DefaultContainerService.java
index 13e1030..6031117 100644
--- a/frameworks/base/packages/DefaultContainerService/src/com/android/defcontainer/DefaultContainerService.java
+++ b/frameworks/base/packages/DefaultContainerService/src/com/android/defcontainer/DefaultContainerService.java
@@ -234,7 +234,7 @@ public class DefaultContainerService extends IntentService {
         public long calculateDirectorySize(String path) throws RemoteException {
             Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
 
-            final File dir = Environment.maybeTranslateEmulatedPathToInternal(new File(path));
+            final File dir = new File(path);
             if (dir.exists() && dir.isDirectory()) {
                 final String targetPath = dir.getAbsolutePath();
                 return MeasurementUtils.measureDirectory(targetPath);
@@ -764,7 +764,7 @@ public class DefaultContainerService extends IntentService {
             prefer = PREFER_INTERNAL;
         }
 
-        final boolean emulated = Environment.isExternalStorageEmulated();
+        final boolean externalApps = Environment.isExternalAppsAvailableAndMounted();
 
         final File apkFile = new File(archiveFilePath);
 
@@ -778,7 +778,7 @@ public class DefaultContainerService extends IntentService {
         }
 
         boolean fitsOnSd = false;
-        if (!emulated && (checkBoth || prefer == PREFER_EXTERNAL)) {
+        if (externalApps && (checkBoth || prefer == PREFER_EXTERNAL)) {
             try {
                 fitsOnSd = isUnderExternalThreshold(apkFile, isForwardLocked);
             } catch (IOException e) {
@@ -790,7 +790,7 @@ public class DefaultContainerService extends IntentService {
             if (fitsOnInternal) {
                 return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
             }
-        } else if (!emulated && prefer == PREFER_EXTERNAL) {
+        } else if (externalApps && prefer == PREFER_EXTERNAL) {
             if (fitsOnSd) {
                 return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
             }
@@ -799,7 +799,7 @@ public class DefaultContainerService extends IntentService {
         if (checkBoth) {
             if (fitsOnInternal) {
                 return PackageHelper.RECOMMEND_INSTALL_INTERNAL;
-            } else if (!emulated && fitsOnSd) {
+            } else if (externalApps && fitsOnSd) {
                 return PackageHelper.RECOMMEND_INSTALL_EXTERNAL;
             }
         }
@@ -809,7 +809,7 @@ public class DefaultContainerService extends IntentService {
          * the media was unavailable. Otherwise, indicate there was insufficient
          * storage space available.
          */
-        if (!emulated && (checkBoth || prefer == PREFER_EXTERNAL)
+        if (externalApps && (checkBoth || prefer == PREFER_EXTERNAL)
                 && !Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
             return PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE;
         } else {
@@ -853,15 +853,16 @@ public class DefaultContainerService extends IntentService {
      */
     private boolean isUnderExternalThreshold(File apkFile, boolean isForwardLocked)
             throws IOException {
-        if (Environment.isExternalStorageEmulated()) {
+        if (!Environment.isExternalAppsAvailableAndMounted()) {
             return false;
         }
 
         final int sizeMb = calculateContainerSize(apkFile, isForwardLocked);
 
         final int availSdMb;
-        if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
-            final StatFs sdStats = new StatFs(Environment.getExternalStorageDirectory().getPath());
+        if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalAppsVolumeState())) {
+            final StatFs sdStats = new StatFs(
+                    Environment.getExternalAppsVolumeDirectory().getPath());
             final int blocksToMb = (1 << 20) / sdStats.getBlockSize();
             availSdMb = sdStats.getAvailableBlocks() / blocksToMb;
         } else {
diff --git a/frameworks/base/services/java/com/android/server/MountService.java b/frameworks/base/services/java/com/android/server/MountService.java
old mode 100644
new mode 100755
index 4c5a5c2..8a16a07
--- a/frameworks/base/services/java/com/android/server/MountService.java
+++ b/frameworks/base/services/java/com/android/server/MountService.java
@@ -704,7 +704,7 @@ class MountService extends IMountService.Stub
 
         // Tell PackageManager about changes to primary volume state, but only
         // when not emulated.
-        if (volume.isPrimary() && !volume.isEmulated()) {
+        if (volume.isExternalApps()) {
             if (Environment.MEDIA_UNMOUNTED.equals(state)) {
                 mPms.updateExternalMediaStatus(false, false);
 
@@ -1083,7 +1083,7 @@ class MountService extends IMountService.Stub
         Runtime.getRuntime().gc();
 
         // Redundant probably. But no harm in updating state again.
-        if (isPrimaryStorage(path)) {
+        if (isExternalApps(path)) {
             mPms.updateExternalMediaStatus(false, false);
         }
         try {
@@ -1265,18 +1265,21 @@ class MountService extends IMountService.Stub
                     // resource parser does not support longs, so XML value is in megabytes
                     long maxFileSize = a.getInt(
                             com.android.internal.R.styleable.Storage_maxFileSize, 0) * 1024L * 1024L;
+                    boolean externalApps = a.getBoolean(
+                            com.android.internal.R.styleable.Storage_externalApps, false);
 
                     Slog.d(TAG, "got storage path: " + path + " description: " + description +
                             " primary: " + primary + " removable: " + removable +
                             " emulated: " + emulated +  " mtpReserve: " + mtpReserve +
                             " allowMassStorage: " + allowMassStorage +
-                            " maxFileSize: " + maxFileSize);
+                            " maxFileSize: " + maxFileSize +
+                            " externalApps: " + externalApps);
 
                     if (emulated && primary) {
                         // For devices with emulated primary storage,
                         // we create separate volumes for each known user.
                         mEmulatedTemplate = new StorageVolume(null, descriptionId, true, false,
-                                true, mtpReserve, false, maxFileSize, null);
+                                true, mtpReserve, false, maxFileSize, null, externalApps);
 
                         final UserManagerService userManager = UserManagerService.getInstance();
                         for (UserInfo user : userManager.getUsers(false)) {
@@ -1289,7 +1292,7 @@ class MountService extends IMountService.Stub
                         } else {
                             final StorageVolume volume = new StorageVolume(new File(path),
                                     descriptionId, primary, removable, emulated, mtpReserve,
-                                    allowMassStorage, maxFileSize, null);
+                                    allowMassStorage, maxFileSize, null, externalApps);
                             addVolumeLocked(volume);
 
                             // Until we hear otherwise, treat as unmounted
@@ -1546,6 +1549,17 @@ class MountService extends IMountService.Stub
         }
     }
 
+    private boolean isExternalApps(String path) {
+        synchronized (mVolumesLock) {
+            for (StorageVolume volume : mVolumes) {
+                if (volume.isExternalApps() && volume.getPath().equals(path)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+
     private boolean isPrimaryStorage(String path) {
         synchronized (mVolumesLock) {
             for (StorageVolume volume : mVolumes) {

project packages/apps/Settings/
diff --git a/packages/apps/Settings/res/values/cm_strings.xml b/packages/apps/Settings/res/values/cm_strings.xml
index 79c8a8c..2b89779 100644
--- a/packages/apps/Settings/res/values/cm_strings.xml
+++ b/packages/apps/Settings/res/values/cm_strings.xml
@@ -1466,4 +1466,13 @@ two in order to insert additional control points. \'Remove\' deletes the selecte
     <string name="lock_to_cyanogen_disable_msg">Disabling this feature will allow unauthorized users to reset your phone to factory defaults if it is stolen. Your personal data may not be protected. Do you want to disable this feature?</string>
     <string name="lock_to_cyanogen_master_clear_warning">Device Protection is enabled. Please disable to continue resetting your device.</string>
 
+    <!-- App moving -->
+    <string name="app_moving_enable">Enable app moving</string>
+    <string name="app_moving_disable">Disable app moving</string>
+    <string name="app_moving_reboot_title">Reboot now?</string>
+    <string name="app_moving_reboot_enabled_desc">Successfully enabled application moving.\n\nThe device needs to be rebooted for the setting to take effect.</string>
+    <string name="app_moving_reboot_disabled_desc">Successfully disabled application moving.\n\nThe device needs to be rebooted for the setting to take effect.</string>
+    <string name="app_moving_reboot_now_button">Reboot now</string>
+    <string name="app_moving_reboot_later_button">Reboot later</string>
+
 </resources>
diff --git a/packages/apps/Settings/src/com/android/settings/applications/InstalledAppDetails.java b/packages/apps/Settings/src/com/android/settings/applications/InstalledAppDetails.java
index 36fce36..5b79636 100644
--- a/packages/apps/Settings/src/com/android/settings/applications/InstalledAppDetails.java
+++ b/packages/apps/Settings/src/com/android/settings/applications/InstalledAppDetails.java
@@ -305,7 +305,7 @@ public class InstalledAppDetails extends Fragment
     }
 
     private void initMoveButton() {
-        if (Environment.isExternalStorageEmulated()) {
+        if (!Environment.isExternalAppsAvailableAndMounted()) {
             mMoveAppButton.setVisibility(View.INVISIBLE);
             return;
         }
@@ -492,7 +492,7 @@ public class InstalledAppDetails extends Fragment
         mExternalCodeSize = (TextView)view.findViewById(R.id.external_code_size_text);
         mExternalDataSize = (TextView)view.findViewById(R.id.external_data_size_text);
 
-        if (Environment.isExternalStorageEmulated()) {
+        if (!Environment.isExternalAppsAvailableAndMounted()) {
             ((View)mExternalCodeSize.getParent()).setVisibility(View.GONE);
             ((View)mExternalDataSize.getParent()).setVisibility(View.GONE);
         }
@@ -1060,7 +1060,7 @@ public class InstalledAppDetails extends Fragment
             mHaveSizes = true;
             long codeSize = mAppEntry.codeSize;
             long dataSize = mAppEntry.dataSize;
-            if (Environment.isExternalStorageEmulated()) {
+            if (!Environment.isExternalAppsAvailableAndMounted()) {
                 codeSize += mAppEntry.externalCodeSize;
                 dataSize +=  mAppEntry.externalDataSize;
             } else {
diff --git a/packages/apps/Settings/src/com/android/settings/applications/ManageApplications.java b/packages/apps/Settings/src/com/android/settings/applications/ManageApplications.java
index 9456286..adbbaf5 100644
--- a/packages/apps/Settings/src/com/android/settings/applications/ManageApplications.java
+++ b/packages/apps/Settings/src/com/android/settings/applications/ManageApplications.java
@@ -41,6 +41,7 @@ import android.os.Bundle;
 import android.os.Environment;
 import android.os.Handler;
 import android.os.IBinder;
+import android.os.PowerManager;
 import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.UserHandle;
@@ -77,6 +78,7 @@ import com.android.settings.Settings.StorageUseActivity;
 import com.android.settings.applications.ApplicationsState.AppEntry;
 import com.android.settings.deviceinfo.StorageMeasurement;
 import com.android.settings.Utils;
+import com.android.internal.util.slim.AppMoving;
 
 import java.util.ArrayList;
 import java.util.Comparator;
@@ -144,6 +146,7 @@ public class ManageApplications extends Fragment implements
     private static final String EXTRA_SORT_ORDER = "sortOrder";
     private static final String EXTRA_SHOW_BACKGROUND = "showBackground";
     private static final String EXTRA_DEFAULT_LIST_TYPE = "defaultListType";
+    private static final String EXTRA_REBOOT_DIALOG = "rebootDialog";
     private static final String EXTRA_RESET_DIALOG = "resetDialog";
 
     // attributes used as keys when passing values to InstalledAppDetails activity
@@ -169,8 +172,10 @@ public class ManageApplications extends Fragment implements
     public static final int SORT_ORDER_SIZE = MENU_OPTIONS_BASE + 5;
     public static final int SHOW_RUNNING_SERVICES = MENU_OPTIONS_BASE + 6;
     public static final int SHOW_BACKGROUND_PROCESSES = MENU_OPTIONS_BASE + 7;
-    public static final int RESET_APP_PREFERENCES = MENU_OPTIONS_BASE + 8;
-    public static final int SHOW_PROTECTED_APPS = MENU_OPTIONS_BASE + 9;
+    public static final int APP_MOVING_ENABLE = MENU_OPTIONS_BASE + 8;
+    public static final int APP_MOVING_DISABLE = MENU_OPTIONS_BASE + 9;
+    public static final int RESET_APP_PREFERENCES = MENU_OPTIONS_BASE + 10;
+    public static final int SHOW_PROTECTED_APPS = MENU_OPTIONS_BASE + 11;
 
     // sort order
     private int mSortOrder = SORT_ORDER_ALPHA;
@@ -338,7 +343,7 @@ public class ManageApplications extends Fragment implements
                 if (mContainerService != null) {
                     try {
                         final long[] stats = mContainerService.getFileSystemStats(
-                                Environment.getExternalStorageDirectory().getPath());
+                                Environment.getExternalAppsVolumeDirectory().getPath());
                         mTotalStorage = stats[0];
                         mFreeStorage = stats[1];
                     } catch (RemoteException e) {
@@ -366,13 +371,13 @@ public class ManageApplications extends Fragment implements
                     }
                 }
 
-                final boolean emulatedStorage = Environment.isExternalStorageEmulated();
+                final boolean externalApps = Environment.isExternalAppsAvailableAndMounted();
                 if (mApplications != null) {
                     final int N = mApplications.getCount();
                     for (int i=0; i<N; i++) {
                         ApplicationsState.AppEntry ae = mApplications.getAppEntry(i);
                         mAppStorage += ae.codeSize + ae.dataSize;
-                        if (emulatedStorage) {
+                        if (!externalApps) {
                             mAppStorage += ae.externalCodeSize + ae.externalDataSize;
                         }
                     }
@@ -466,6 +471,7 @@ public class ManageApplications extends Fragment implements
     private View mRootView;
     private ViewPager mViewPager;
 
+    AlertDialog mRebootDialog;
     AlertDialog mResetDialog;
 
     class MyPagerAdapter extends PagerAdapter
@@ -608,8 +614,8 @@ public class ManageApplications extends Fragment implements
             if (DEBUG) Log.i(TAG, "Rebuilding app list...");
             ApplicationsState.AppFilter filterObj;
             Comparator<AppEntry> comparatorObj;
-            boolean emulated = Environment.isExternalStorageEmulated();
-            if (emulated) {
+            boolean externalApps = Environment.isExternalAppsAvailableAndMounted();
+            if (!externalApps) {
                 mWhichSize = SIZE_TOTAL;
             } else {
                 mWhichSize = SIZE_INTERNAL;
@@ -620,7 +626,7 @@ public class ManageApplications extends Fragment implements
                     break;
                 case FILTER_APPS_SDCARD:
                     filterObj = ApplicationsState.ON_SD_CARD_FILTER;
-                    if (!emulated) {
+                    if (externalApps) {
                         mWhichSize = SIZE_EXTERNAL;
                     }
                     break;
@@ -873,7 +879,7 @@ public class ManageApplications extends Fragment implements
                 LIST_TYPE_DOWNLOADED, this, savedInstanceState);
         mTabs.add(tab);
 
-        if (!Environment.isExternalStorageEmulated()) {
+        if (Environment.isExternalAppsAvailableAndMounted()) {
             tab = new TabInfo(this, mApplicationsState,
                     getActivity().getString(R.string.filter_apps_onsdcard),
                     LIST_TYPE_SDCARD, this, savedInstanceState);
@@ -922,6 +928,10 @@ public class ManageApplications extends Fragment implements
             ((PreferenceFrameLayout.LayoutParams) rootView.getLayoutParams()).removeBorders = true;
         }
 
+        if (savedInstanceState != null && savedInstanceState.getBoolean(EXTRA_REBOOT_DIALOG)) {
+            buildRebootDialog();
+        }
+
         if (savedInstanceState != null && savedInstanceState.getBoolean(EXTRA_RESET_DIALOG)) {
             buildResetDialog();
         }
@@ -962,6 +972,9 @@ public class ManageApplications extends Fragment implements
             outState.putInt(EXTRA_DEFAULT_LIST_TYPE, mDefaultListType);
         }
         outState.putBoolean(EXTRA_SHOW_BACKGROUND, mShowBackground);
+        if (mRebootDialog != null) {
+            outState.putBoolean(EXTRA_REBOOT_DIALOG, true);
+        }
         if (mResetDialog != null) {
             outState.putBoolean(EXTRA_RESET_DIALOG, true);
         }
@@ -979,6 +992,12 @@ public class ManageApplications extends Fragment implements
     @Override
     public void onStop() {
         super.onStop();
+
+        if (mRebootDialog != null) {
+            mRebootDialog.dismiss();
+            mRebootDialog = null;
+        }
+
         if (mResetDialog != null) {
             mResetDialog.dismiss();
             mResetDialog = null;
@@ -1049,10 +1068,14 @@ public class ManageApplications extends Fragment implements
                 .setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
         menu.add(0, SHOW_BACKGROUND_PROCESSES, 3, R.string.show_background_processes)
                 .setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
-        menu.add(0, RESET_APP_PREFERENCES, 4, R.string.reset_app_preferences)
+		menu.add(0, APP_MOVING_ENABLE, 4, R.string.app_moving_enable)
+                .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
+        menu.add(0, APP_MOVING_DISABLE, 5, R.string.app_moving_disable)
+                .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
+        menu.add(0, RESET_APP_PREFERENCES, 6, R.string.reset_app_preferences)
                 .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
         if (!Utils.isRestrictedProfile(getActivity())) {
-            menu.add(0, SHOW_PROTECTED_APPS, 5, R.string.protected_apps)
+            menu.add(0, SHOW_PROTECTED_APPS, 7, R.string.protected_apps)
                     .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
         }
         updateOptionsMenu();
@@ -1091,6 +1114,8 @@ public class ManageApplications extends Fragment implements
             mOptionsMenu.findItem(SORT_ORDER_SIZE).setVisible(false);
             mOptionsMenu.findItem(SHOW_RUNNING_SERVICES).setVisible(showingBackground);
             mOptionsMenu.findItem(SHOW_BACKGROUND_PROCESSES).setVisible(!showingBackground);
+            mOptionsMenu.findItem(APP_MOVING_ENABLE).setVisible(false);
+            mOptionsMenu.findItem(APP_MOVING_DISABLE).setVisible(false);
             mOptionsMenu.findItem(RESET_APP_PREFERENCES).setVisible(false);
             if (!Utils.isRestrictedProfile(getActivity())) {
                 mOptionsMenu.findItem(SHOW_PROTECTED_APPS).setVisible(true);
@@ -1101,6 +1126,8 @@ public class ManageApplications extends Fragment implements
             mOptionsMenu.findItem(SORT_ORDER_SIZE).setVisible(mSortOrder != SORT_ORDER_SIZE);
             mOptionsMenu.findItem(SHOW_RUNNING_SERVICES).setVisible(false);
             mOptionsMenu.findItem(SHOW_BACKGROUND_PROCESSES).setVisible(false);
+            mOptionsMenu.findItem(APP_MOVING_ENABLE).setVisible(!AppMoving.isEnabled());
+            mOptionsMenu.findItem(APP_MOVING_DISABLE).setVisible(AppMoving.isEnabled());
             mOptionsMenu.findItem(RESET_APP_PREFERENCES).setVisible(true);
             if (!Utils.isRestrictedProfile(getActivity())) {
                 mOptionsMenu.findItem(SHOW_PROTECTED_APPS).setVisible(true);
@@ -1108,6 +1135,22 @@ public class ManageApplications extends Fragment implements
         }
     }
 
+    void buildRebootDialog() {
+        if (mRebootDialog == null) {
+            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
+            builder.setTitle(R.string.app_moving_reboot_title);
+            if (AppMoving.isEnabled()) {
+                builder.setMessage(R.string.app_moving_reboot_enabled_desc);
+            } else {
+                builder.setMessage(R.string.app_moving_reboot_disabled_desc);
+            }
+            builder.setPositiveButton(R.string.app_moving_reboot_now_button, this);
+            builder.setNegativeButton(R.string.app_moving_reboot_later_button, null);
+            mRebootDialog = builder.show();
+            mRebootDialog.setOnDismissListener(this);
+        }
+    }
+
     void buildResetDialog() {
         if (mResetDialog == null) {
             AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
@@ -1122,7 +1165,9 @@ public class ManageApplications extends Fragment implements
 
     @Override
     public void onDismiss(DialogInterface dialog) {
-        if (mResetDialog == dialog) {
+        if (mRebootDialog == dialog) {
+            mRebootDialog = null;
+        } else if (mResetDialog == dialog) {
             mResetDialog = null;
         }
     }
@@ -1130,7 +1175,12 @@ public class ManageApplications extends Fragment implements
 
     @Override
     public void onClick(DialogInterface dialog, int which) {
-        if (mResetDialog == dialog) {
+        if (mRebootDialog == dialog) {
+            mRebootDialog = null;
+            PowerManager pm = (PowerManager)
+                    getActivity().getSystemService(Context.POWER_SERVICE);
+            pm.reboot(null);
+        } else if (mResetDialog == dialog) {
             final PackageManager pm = getActivity().getPackageManager();
             final IPackageManager mIPm = IPackageManager.Stub.asInterface(
                     ServiceManager.getService("package"));
@@ -1217,6 +1267,12 @@ public class ManageApplications extends Fragment implements
             if (mCurTab != null && mCurTab.mRunningProcessesView != null) {
                 mCurTab.mRunningProcessesView.mAdapter.setShowBackground(true);
             }
+        } else if (menuId == APP_MOVING_ENABLE) {
+            AppMoving.setEnabled(true);
+            buildRebootDialog();
+        } else if (menuId == APP_MOVING_DISABLE) {
+            AppMoving.setEnabled(false);
+            buildRebootDialog();
         } else if (menuId == RESET_APP_PREFERENCES) {
             buildResetDialog();
         } else if (menuId == SHOW_PROTECTED_APPS) {
diff --git a/packages/apps/Settings/src/com/android/settings/deviceinfo/StorageMeasurement.java b/packages/apps/Settings/src/com/android/settings/deviceinfo/StorageMeasurement.java
index 34ef62b..e1dd3bb 100644
--- a/packages/apps/Settings/src/com/android/settings/deviceinfo/StorageMeasurement.java
+++ b/packages/apps/Settings/src/com/android/settings/deviceinfo/StorageMeasurement.java
@@ -249,7 +249,7 @@ public class StorageMeasurement {
                 long codeSize = stats.codeSize;
                 long dataSize = stats.dataSize;
                 long cacheSize = stats.cacheSize;
-                if (Environment.isExternalStorageEmulated()) {
+                if (!Environment.isExternalAppsAvailableAndMounted()) {
                     // Include emulated storage when measuring internal. OBB is
                     // shared on emulated storage, so treat as code.
                     codeSize += stats.externalCodeSize + stats.externalObbSize;

project system/vold/
diff --git a/system/vold/CommandListener.cpp b/system/vold/CommandListener.cpp
index 70fe24d..dc8cdad 100644
--- a/system/vold/CommandListener.cpp
+++ b/system/vold/CommandListener.cpp
@@ -314,7 +314,10 @@ void CommandListener::AsecCmd::listAsecsInDirectory(SocketClient *cli, const cha
     while (!readdir_r(d, dent, &result) && result != NULL) {
         if (dent->d_name[0] == '.')
             continue;
-        if (dent->d_type != DT_REG)
+        // For whatever reason, the exFAT fuse driver reports DT_UNKNOWN for
+        // the .asec files, so we'll have to allow that to make external apps
+        // work properly.
+        if (dent->d_type != DT_REG && dent->d_type != DT_UNKNOWN)
             continue;
         size_t name_len = strlen(dent->d_name);
         if (name_len > 5 && name_len < 260 &&
diff --git a/system/vold/Volume.cpp b/Vsystem/vold/olume.cpp
index 4196b2f..f09b126 100644
--- a/system/vold/Volume.cpp
+++ b/system/vold/Volume.cpp
@@ -217,6 +217,22 @@ void Volume::setUserLabel(const char* userLabel) {
             msg, false);
 }
 
+bool Volume::isExternalAppsEnabled() {
+    const char* disablePath = "/data/system/no-external-apps";
+
+    int flags = getFlags();
+    bool externalApps = (flags & VOL_EXTERNAL_APPS) != 0;
+
+    if (externalApps) {
+        if (access(disablePath, F_OK) != -1) {
+            SLOGV("Application moving disabled; will not touch ASEC\n");
+            return false;
+        }
+        return true;
+    }
+    return false;
+}
+
 void Volume::setState(int state) {
     char msg[255];
     int oldState = mState;
@@ -379,6 +395,7 @@ int Volume::mountVol() {
 
     int flags = getFlags();
     bool providesAsec = (flags & VOL_PROVIDES_ASEC) != 0;
+    bool externalApps = (flags & VOL_EXTERNAL_APPS) != 0 && isExternalAppsEnabled();
 
     // TODO: handle "bind" style mounts, for emulated storage
 
@@ -594,7 +611,8 @@ int Volume::mountVol() {
         extractMetadata(devicePath);
 
 #ifndef MINIVOLD
-        if (providesAsec && mountAsecExternal() != 0) {
+        // Create android_secure on external SD
+        if ((externalApps || providesAsec) && mountAsecExternal() != 0) {
             SLOGE("Failed to mount secure area (%s)", strerror(errno));
             umount(getMountpoint());
             setState(Volume::State_Idle);
@@ -682,6 +700,7 @@ int Volume::doUnmount(const char *path, bool force) {
 int Volume::unmountVol(bool force, bool revert) {
     int flags = getFlags();
     bool providesAsec = (flags & VOL_PROVIDES_ASEC) != 0;
+    bool externalApps = (flags & VOL_EXTERNAL_APPS) != 0 && isExternalAppsEnabled();
 
     if (getState() != Volume::State_Mounted) {
         SLOGE("Volume %s unmount request when not mounted", getLabel());
@@ -700,7 +719,7 @@ int Volume::unmountVol(bool force, bool revert) {
 
     // TODO: determine failure mode if FUSE times out
 
-    if (providesAsec && doUnmount(Volume::SEC_ASECDIR_EXT, force) != 0) {
+    if ((externalApps || providesAsec) && doUnmount(Volume::SEC_ASECDIR_EXT, force) != 0) {
         SLOGE("Failed to unmount secure area on %s (%s)", getMountpoint(), strerror(errno));
         goto out_mounted;
     }
@@ -736,7 +755,7 @@ int Volume::unmountVol(bool force, bool revert) {
     return 0;
 
 fail_remount_secure:
-    if (providesAsec && mountAsecExternal() != 0) {
+    if ((externalApps || providesAsec) && mountAsecExternal() != 0) {
         SLOGE("Failed to remount secure area (%s)", strerror(errno));
         goto out_nomedia;
     }
diff --git a/system/vold/Volume.h b/system/vold/Volume.h
index c1be400..a0b6d50 100644
--- a/system/vold/Volume.h
+++ b/system/vold/Volume.h
@@ -79,6 +79,7 @@ public:
     const char* getLabel() { return mLabel; }
     const char* getUuid() { return mUuid; }
     const char* getUserLabel() { return mUserLabel; }
+    bool isExternalAppsEnabled();
     int getState() { return mState; }
     int getFlags() { return mFlags; };
 
diff --git a/VolumeManager.cpp b/VolumeManager.cpp
index cb23d95..4d26862 100644
--- a/system/vold/VolumeManager.cpp
+++ b/system/vold/VolumeManager.cpp
@@ -1704,8 +1704,11 @@ bool VolumeManager::isMountpointMounted(const char *mp)
 }
 
 int VolumeManager::cleanupAsec(Volume *v, bool force) {
-    // Only primary storage needs ASEC cleanup
-    if (!(v->getFlags() & VOL_PROVIDES_ASEC)) {
+    // Continue for the primary storage (VOL_PROVIDES_ASEC) and for the
+    // external apps volume (VOL_EXTERNAL_APPS) if app moving is enabled
+    if ((v->getFlags() & VOL_PROVIDES_ASEC) == 0
+                && ((v->getFlags() & VOL_EXTERNAL_APPS) == 0
+                        || !v->isExternalAppsEnabled())) {
         return 0;
     }
 
diff --git a/system/vold/cryptfs.h b/system/vold/cryptfs.h
index 162159e..4e318b8 100644
--- a/system/vold/cryptfs.h
+++ b/system/vold/cryptfs.h
@@ -131,6 +131,7 @@ struct volume_info {
 #define VOL_ENCRYPTABLE    0x2
 #define VOL_PRIMARY        0x4
 #define VOL_PROVIDES_ASEC  0x8
+#define VOL_EXTERNAL_APPS  0x10
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/system/vold/main.cpp b/system/vold/main.cpp
index 22bae40..5197b35 100644
--- a/system/vold/main.cpp
+++ b/system/vold/main.cpp
@@ -36,6 +36,10 @@
 #include "DirectVolume.h"
 #include "cryptfs.h"
 
+#ifndef EXTERNAL_APPS_DEVICE_LABEL
+#define EXTERNAL_APPS_DEVICE_LABEL ""
+#endif
+
 static int process_config(VolumeManager *vm);
 static void coldboot(const char *path);
 
@@ -184,6 +188,10 @@ static int process_config(VolumeManager *vm)
             if (fs_mgr_is_noemulatedsd(&fstab->recs[i])) {
                 flags |= VOL_PROVIDES_ASEC;
             }
+            /* Set this flag if the storage device supports having external apps */
+            if (strcmp(fstab->recs[i].label, EXTERNAL_APPS_DEVICE_LABEL) == 0) {
+                flags |= VOL_EXTERNAL_APPS;
+            }
             dv = new DirectVolume(vm, &(fstab->recs[i]), flags);
 
             if (dv->addPath(fstab->recs[i].blk_device)) {

