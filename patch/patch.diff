diff -ur CM13.0_loganxx/build/core/tasks/kernel.mk CM13.0_loganxx_patched/build/core/tasks/kernel.mk
--- CM13.0_loganxx/build/core/tasks/kernel.mk	2016-02-25 18:15:20.000000000 +0000
+++ CM13.0_loganxx_patched/build/core/tasks/kernel.mk	2016-02-25 18:31:51.000000000 +0000
@@ -208,7 +208,11 @@
     ccache := $(strip $(wildcard $(ccache)))
 endif
 
-KERNEL_CROSS_COMPILE := CROSS_COMPILE="$(ccache) $(KERNEL_TOOLCHAIN_PATH)"
+ifneq ($(TARGET_KERNEL_CUSTOM_TOOLCHAIN),)     
+    KERNEL_CROSS_COMPILE := CROSS_COMPILE="$(ccache) $(ANDROID_BUILD_TOP)/prebuilts/gcc/linux-x86/arm/$(TARGET_KERNEL_CUSTOM_TOOLCHAIN)/bin/arm-eabi-"      
+else
+	KERNEL_CROSS_COMPILE := CROSS_COMPILE="$(ccache) $(KERNEL_TOOLCHAIN_PATH)"
+endif
 ccache =
 
 define mv-modules
diff -ur CM13.0_loganxx/external/icu/icu4c/source/common/ucnv.c CM13.0_loganxx_patched/external/icu/icu4c/source/common/ucnv.c
--- CM13.0_loganxx/external/icu/icu4c/source/common/ucnv.c	2016-02-25 18:16:25.000000000 +0000
+++ CM13.0_loganxx_patched/external/icu/icu4c/source/common/ucnv.c	2016-02-25 18:32:33.000000000 +0000
@@ -2914,6 +2914,76 @@
             return FALSE;
     }
 }
+
+U_CAPI void    U_EXPORT2 ucnv_setToUCallBack_48 (UConverter * converter,
+                            UConverterToUCallback newAction,
+                            const void* newContext,
+                            UConverterToUCallback *oldAction,
+                            const void** oldContext,
+                            UErrorCode * err) {
+  ucnv_setToUCallBack(converter, newAction, newContext,
+        oldAction, oldContext, err);
+}
+
+U_CAPI void  U_EXPORT2 ucnv_close_48 (UConverter * converter) {
+  ucnv_close (converter);
+}
+
+U_CAPI void  U_EXPORT2
+ucnv_setFromUCallBack_48 (UConverter * converter,
+                            UConverterFromUCallback newAction,
+                            const void* newContext,
+                            UConverterFromUCallback *oldAction,
+                            const void** oldContext,
+                            UErrorCode * err) {
+
+  ucnv_setFromUCallBack(converter, newAction, newContext, oldAction,
+        oldContext, err);
+}
+
+U_CAPI void U_EXPORT2
+ucnv_convertEx_48 (UConverter *targetCnv, UConverter *sourceCnv,
+               char **target, const char *targetLimit,
+               const char **source, const char *sourceLimit,
+               UChar *pivotStart, UChar **pivotSource,
+               UChar **pivotTarget, const UChar *pivotLimit,
+               UBool reset, UBool flush,
+               UErrorCode *pErrorCode) {
+  ucnv_convertEx(targetCnv, sourceCnv, target, targetLimit, source,
+        sourceLimit, pivotStart, pivotSource,
+        pivotTarget, pivotLimit, reset, flush,
+        pErrorCode);
+}
+
+U_CAPI UConverter* U_EXPORT2
+ucnv_open_48 (const char *name,
+                       UErrorCode * err) {
+  return ucnv_open(name, err);
+}
+
+U_STABLE void U_EXPORT2 UCNV_FROM_U_CALLBACK_STOP_48 (
+                  const void *context,
+                  UConverterFromUnicodeArgs *fromUArgs,
+                  const UChar* codeUnits,
+                  int32_t length,
+                  UChar32 codePoint,
+                  UConverterCallbackReason reason,
+                  UErrorCode * err) {
+  return UCNV_FROM_U_CALLBACK_STOP(context, fromUArgs, codeUnits,
+      length, codePoint, reason, err);
+}
+
+U_STABLE void U_EXPORT2 UCNV_TO_U_CALLBACK_STOP_48 (
+                  const void *context,
+                  UConverterToUnicodeArgs *toUArgs,
+                  const char* codeUnits,
+                  int32_t length,
+                  UConverterCallbackReason reason,
+                  UErrorCode * err) {
+  return UCNV_TO_U_CALLBACK_STOP(context, toUArgs, codeUnits, length,
+      reason, err);
+}
+
 #endif
 
 /*
diff -ur CM13.0_loganxx/external/sepolicy/domain.te CM13.0_loganxx_patched/external/sepolicy/domain.te
--- CM13.0_loganxx/external/sepolicy/domain.te	2016-02-25 18:17:03.000000000 +0000
+++ CM13.0_loganxx_patched/external/sepolicy/domain.te	2016-02-25 18:33:31.000000000 +0000
@@ -236,11 +236,11 @@
 # init starts in kernel domain and switches to init domain via setcon in
 # the init.rc, so the setenforce occurs while still in kernel. After
 # switching domains, there is never any need to setenforce again by init.
-neverallow domain kernel:security setenforce;
-neverallow { domain -kernel } kernel:security setcheckreqprot;
+# neverallow domain kernel:security setenforce;
+# neverallow { domain -kernel } kernel:security setcheckreqprot;
 
 # No booleans in AOSP policy, so no need to ever set them.
-neverallow domain kernel:security setbool;
+# neverallow domain kernel:security setbool;
 
 # Adjusting the AVC cache threshold.
 # Not presently allowed to anything in policy, but possibly something
diff -ur CM13.0_loganxx/frameworks/av/include/media/stagefright/ColorConverter.h CM13.0_loganxx_patched/frameworks/av/include/media/stagefright/ColorConverter.h
--- CM13.0_loganxx/frameworks/av/include/media/stagefright/ColorConverter.h	2016-02-25 18:17:20.000000000 +0000
+++ CM13.0_loganxx_patched/frameworks/av/include/media/stagefright/ColorConverter.h	2016-02-25 18:34:05.000000000 +0000
@@ -66,6 +66,9 @@
 
     status_t convertCbYCrY(
             const BitmapParams &src, const BitmapParams &dst);
+			
+	status_t convertYCbYCr(
+            const BitmapParams &src, const BitmapParams &dst);		
 
     status_t convertYUV420Planar(
             const BitmapParams &src, const BitmapParams &dst);
diff -ur CM13.0_loganxx/frameworks/av/media/libstagefright/ACodec.cpp CM13.0_loganxx_patched/frameworks/av/media/libstagefright/ACodec.cpp
--- CM13.0_loganxx/frameworks/av/media/libstagefright/ACodec.cpp	2016-02-25 18:17:20.000000000 +0000
+++ CM13.0_loganxx_patched/frameworks/av/media/libstagefright/ACodec.cpp	2016-02-25 19:26:57.000000000 +0000
@@ -784,11 +784,11 @@
 
     status_t err;
     if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
-        if (storingMetadataInDecodedBuffers()) {
-            err = allocateOutputMetadataBuffers();
-        } else {
+        //if (storingMetadataInDecodedBuffers()) {
+		//    err = allocateOutputMetadataBuffers();
+        //} else {
             err = allocateOutputBuffersFromNativeWindow();
-        }
+        //}
     } else {
         OMX_PARAM_PORTDEFINITIONTYPE def;
         InitOMXParams(&def);
@@ -924,6 +924,25 @@
     setNativeWindowColorFormat(eNativeColorFormat);
 #endif
 
+	ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s] def.format.video.eColorFormat(%i)", mComponentName.c_str(), def.format.video.eColorFormat);
+	OMX_COLOR_FORMATTYPE HalColorFormat;
+	switch (def.format.video.eColorFormat) {
+		case OMX_COLOR_FormatYCbYCr:{
+			def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			status_t clp = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+			ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s] def.format.video.eColorFormat NOW (%i)", mComponentName.c_str(), def.format.video.eColorFormat);
+			if (clp != OK) {
+				ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s] setParameter(OMX_IndexParamPortDefinition) ERROR", mComponentName.c_str());
+			}
+		}	
+		break;
+		default:
+			ALOGE("ACodec:PATCH:setupNativeWindowSizeFormatAndUsage[%s] def.format.video.eColorFormat Default (%i) (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12", mComponentName.c_str(), (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+		break;
+	}
+
     ALOGV("gralloc usage: %#x(OMX) => %#x(ACodec)", omxUsage, usage);
     err = setNativeWindowSizeFormatAndUsage(
             nativeWindow,
@@ -932,7 +951,7 @@
 #ifdef USE_SAMSUNG_COLORFORMAT
             eNativeColorFormat,
 #else
-            def.format.video.eColorFormat,
+            HalColorFormat,
 #endif
             mRotationDegrees,
             usage);
@@ -1739,13 +1758,13 @@
             mInputMetadataType = kMetadataBufferTypeCameraSource;
         }
 
-        uint32_t usageBits;
-        if (mOMX->getParameter(
-                mNode, (OMX_INDEXTYPE)OMX_IndexParamConsumerUsageBits,
-                &usageBits, sizeof(usageBits)) == OK) {
-            inputFormat->setInt32(
-                    "using-sw-read-often", !!(usageBits & GRALLOC_USAGE_SW_READ_OFTEN));
-        }
+        //uint32_t usageBits;
+        //if (mOMX->getParameter(
+        //        mNode, (OMX_INDEXTYPE)OMX_IndexParamConsumerUsageBits,
+        //        &usageBits, sizeof(usageBits)) == OK) {
+        //    inputFormat->setInt32(
+        //            "using-sw-read-often", !!(usageBits & GRALLOC_USAGE_SW_READ_OFTEN));
+        //}
     }
 
     int32_t prependSPSPPS = 0;
@@ -2247,20 +2266,20 @@
         err = setMinBufferSize(kPortIndexInput, 8192);  // XXX
     }
 
-    int32_t priority;
-    if (msg->findInt32("priority", &priority)) {
-        err = setPriority(priority);
-    }
-
-    int32_t rateInt = -1;
-    float rateFloat = -1;
-    if (!msg->findFloat("operating-rate", &rateFloat)) {
-        msg->findInt32("operating-rate", &rateInt);
-        rateFloat = (float)rateInt;  // 16MHz (FLINTMAX) is OK for upper bound.
-    }
-    if (rateFloat > 0) {
-        err = setOperatingRate(rateFloat, video);
-    }
+    //int32_t priority;
+    //if (msg->findInt32("priority", &priority)) {
+    //    err = setPriority(priority);
+    //}
+
+    //int32_t rateInt = -1;
+    //float rateFloat = -1;
+    //if (!msg->findFloat("operating-rate", &rateFloat)) {
+    //    msg->findInt32("operating-rate", &rateInt);
+    //    rateFloat = (float)rateInt;  // 16MHz (FLINTMAX) is OK for upper bound.
+    //}
+    //if (rateFloat > 0) {
+    //    err = setOperatingRate(rateFloat, video);
+    //}
 
     mBaseOutputFormat = outputFormat;
 
@@ -3948,6 +3967,20 @@
     image.mNumPlanes = 0;
 
     const OMX_COLOR_FORMATTYPE fmt = params.eColorFormat;
+	
+	ALOGE("ACodec:PATCH:describeDefaultColorFormat eColorFormat = %i", params.eColorFormat);
+	
+	switch(params.eColorFormat){
+		case OMX_COLOR_FormatYCbYCr:{
+			ALOGE("ACodec:PATCH:describeDefaultColorFormat eColorFormat = %i SET to %i", params.eColorFormat, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+			params.eColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+		}
+		break;
+		default:
+			ALOGE("ACodec:PATCH:describeDefaultColorFormat default eColorFormat = %i", params.eColorFormat);
+		break;
+	}
+	
     image.mWidth = params.nFrameWidth;
     image.mHeight = params.nFrameHeight;
 
@@ -4127,6 +4160,16 @@
         return BAD_VALUE;
     }
 
+	ALOGE("ACodec:PATCH:getPortFormat[%s] getParameter(OMX_IndexParamPortDefinition) def.format.video.eColorFormat = %i", mComponentName.c_str(), def.format.video.eColorFormat);
+	if(def.format.video.eColorFormat == OMX_COLOR_FormatYCbYCr){
+		ALOGE("ACodec:PATCH:getPortFormat[%s] getParameter(OMX_IndexParamPortDefinition) def.format.video.eColorFormat = %i SET %i", mComponentName.c_str(), def.format.video.eColorFormat, OMX_COLOR_FormatYUV420Planar);
+	    def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+		status_t ert = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+		if (ert != OK) {
+			ALOGE("ACodec:PATCH:getPortFormat[%s] setParameter(OMX_IndexParamPortDefinition) ERROR", mComponentName.c_str());
+		}
+	}
+	
     switch (def.eDomain) {
         case OMX_PortDomainVideo:
         {
@@ -6564,14 +6607,14 @@
         }
     }
 
-    float rate;
-    if (params->findFloat("operating-rate", &rate) && rate > 0) {
-        status_t err = setOperatingRate(rate, mIsVideo);
-        if (err != OK) {
-            ALOGE("Failed to set parameter 'operating-rate' (err %d)", err);
-            return err;
-        }
-    }
+    //float rate;
+    //if (params->findFloat("operating-rate", &rate) && rate > 0) {
+    //    status_t err = setOperatingRate(rate, mIsVideo);
+    //    if (err != OK) {
+    //        ALOGE("Failed to set parameter 'operating-rate' (err %d)", err);
+    //        return err;
+    //    }
+    //}
 
     return OK;
 }
diff -ur CM13.0_loganxx/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp CM13.0_loganxx_patched/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
--- CM13.0_loganxx/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp	2016-02-25 18:17:21.000000000 +0000
+++ CM13.0_loganxx_patched/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp	2016-02-25 19:03:58.000000000 +0000
@@ -44,6 +44,7 @@
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatCbYCrY:
+		case OMX_COLOR_FormatYCbYCr:
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
@@ -109,6 +110,10 @@
         case OMX_COLOR_FormatCbYCrY:
             err = convertCbYCrY(src, dst);
             break;
+			
+		case OMX_COLOR_FormatYCbYCr:
+            err = convertYCbYCr(src, dst);
+            break;	
 
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
             err = convertQCOMYUV420SemiPlanar(src, dst);
@@ -159,6 +164,71 @@
 
             signed u_b = u * 517;
             signed u_g = -u * 100;
+            signed v_g = -v * 208;
+            signed v_r = v * 409;
+
+            signed tmp1 = y1 * 298;
+            signed b1 = (tmp1 + u_b) / 256;
+            signed g1 = (tmp1 + v_g + u_g) / 256;
+            signed r1 = (tmp1 + v_r) / 256;
+
+            signed tmp2 = y2 * 298;
+            signed b2 = (tmp2 + u_b) / 256;
+            signed g2 = (tmp2 + v_g + u_g) / 256;
+            signed r2 = (tmp2 + v_r) / 256;
+
+            uint32_t rgb1 =
+                ((kAdjustedClip[r1] >> 3) << 11)
+                | ((kAdjustedClip[g1] >> 2) << 5)
+                | (kAdjustedClip[b1] >> 3);
+
+            uint32_t rgb2 =
+                ((kAdjustedClip[r2] >> 3) << 11)
+                | ((kAdjustedClip[g2] >> 2) << 5)
+                | (kAdjustedClip[b2] >> 3);
+
+            if (x + 1 < src.cropWidth()) {
+                *(uint32_t *)(&dst_ptr[x]) = (rgb2 << 16) | rgb1;
+            } else {
+                dst_ptr[x] = rgb1;
+            }
+        }
+
+        src_ptr += src.mWidth * 2;
+        dst_ptr += dst.mWidth;
+    }
+
+    return OK;
+}
+
+status_t ColorConverter::convertYCbYCr(
+        const BitmapParams &src, const BitmapParams &dst) {
+		ALOGE("PATCH:ColorConverter:convertYCbYCr");
+    // XXX Untested
+
+    uint8_t *kAdjustedClip = initClip();
+
+    if (!((src.mCropLeft & 1) == 0
+        && src.cropWidth() == dst.cropWidth()
+        && src.cropHeight() == dst.cropHeight())) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    uint16_t *dst_ptr = (uint16_t *)dst.mBits
+        + dst.mCropTop * dst.mWidth + dst.mCropLeft;
+
+    const uint8_t *src_ptr = (const uint8_t *)src.mBits
+        + (src.mCropTop * dst.mWidth + src.mCropLeft) * 2;
+
+    for (size_t y = 0; y < src.cropHeight(); ++y) {
+        for (size_t x = 0; x < src.cropWidth(); x += 2) {
+			signed y1 = (signed)src_ptr[2 * x ] - 16;
+            signed y2 = (signed)src_ptr[2 * x + 2] - 16;
+            signed u = (signed)src_ptr[2 * x + 1] - 128;  
+            signed v = (signed)src_ptr[2 * x + 3] - 128;
+
+            signed u_b = u * 517;
+            signed u_g = -u * 100;
             signed v_g = -v * 208;
             signed v_r = v * 409;
 
diff -ur CM13.0_loganxx/frameworks/av/media/libstagefright/MediaBufferGroup.cpp CM13.0_loganxx_patched/frameworks/av/media/libstagefright/MediaBufferGroup.cpp
--- CM13.0_loganxx/frameworks/av/media/libstagefright/MediaBufferGroup.cpp	2016-02-25 18:17:20.000000000 +0000
+++ CM13.0_loganxx_patched/frameworks/av/media/libstagefright/MediaBufferGroup.cpp	2016-02-17 20:27:58.000000000 +0000
@@ -55,6 +55,13 @@
     mLastBuffer = buffer;
 }
 
+#ifdef ADD_LEGACY_ACQUIRE_BUFFER_SYMBOL
+extern "C" status_t _ZN7android16MediaBufferGroup14acquire_bufferEPPNS_11MediaBufferE(
+    MediaBufferGroup* group, MediaBuffer **out) {
+    return group->acquire_buffer(out, false);
+}
+#endif
+
 status_t MediaBufferGroup::acquire_buffer(
         MediaBuffer **out, bool nonBlocking) {
     Mutex::Autolock autoLock(mLock);
diff -ur CM13.0_loganxx/frameworks/av/media/libstagefright/MPEG4Writer.cpp CM13.0_loganxx_patched/frameworks/av/media/libstagefright/MPEG4Writer.cpp
--- CM13.0_loganxx/frameworks/av/media/libstagefright/MPEG4Writer.cpp	2016-02-25 18:17:20.000000000 +0000
+++ CM13.0_loganxx_patched/frameworks/av/media/libstagefright/MPEG4Writer.cpp	2016-02-25 19:05:17.000000000 +0000
@@ -2356,8 +2356,8 @@
 
         timestampUs -= previousPausedDurationUs;
         if (WARN_UNLESS(timestampUs >= 0ll, "for %s track", trackName)) {
-            copy->release();
-            return ERROR_MALFORMED;
+            //copy->release();
+            //return ERROR_MALFORMED;
         }
 
         if (!mIsAudio) {
@@ -2372,8 +2372,8 @@
             cttsOffsetTimeUs =
                     timestampUs - decodingTimeUs;
             if (WARN_UNLESS(kMaxCttsOffsetTimeUs >= decodingTimeUs - timestampUs, "for %s track", trackName)) {
-                copy->release();
-                return ERROR_MALFORMED;
+                //copy->release();
+                //return ERROR_MALFORMED;
             }
 
             timestampUs = decodingTimeUs;
@@ -2384,8 +2384,8 @@
             currCttsOffsetTimeTicks =
                     (cttsOffsetTimeUs * mTimeScale + 500000LL) / 1000000LL;
             if (WARN_UNLESS(currCttsOffsetTimeTicks <= 0x0FFFFFFFFLL, "for %s track", trackName)) {
-                copy->release();
-                return ERROR_MALFORMED;
+                //copy->release();
+                //return ERROR_MALFORMED;
             }
 
             if (mStszTableEntries->count() == 0) {
@@ -2426,8 +2426,8 @@
         }
 
         if (WARN_UNLESS(timestampUs >= 0ll, "for %s track", trackName)) {
-            copy->release();
-            return ERROR_MALFORMED;
+            //copy->release();
+            //return ERROR_MALFORMED;
         }
 
         ALOGV("%s media time stamp: %" PRId64 " and previous paused duration %" PRId64,
@@ -2447,8 +2447,8 @@
         if (currDurationTicks < 0ll) {
             ALOGE("timestampUs %" PRId64 " < lastTimestampUs %" PRId64 " for %s track",
                 timestampUs, lastTimestampUs, trackName);
-            copy->release();
-            return UNKNOWN_ERROR;
+            //copy->release();
+            //return UNKNOWN_ERROR;
         }
 
         // if the duration is different for this sample, see if it is close enough to the previous
@@ -2546,7 +2546,7 @@
     }
 
     if (isTrackMalFormed()) {
-        err = ERROR_MALFORMED;
+        //err = ERROR_MALFORMED;
     }
 
     mOwner->trackProgressStatus(mTrackId, -1, err);
diff -ur CM13.0_loganxx/frameworks/av/media/libstagefright/OMXCodec.cpp CM13.0_loganxx_patched/frameworks/av/media/libstagefright/OMXCodec.cpp
--- CM13.0_loganxx/frameworks/av/media/libstagefright/OMXCodec.cpp	2016-02-25 18:17:20.000000000 +0000
+++ CM13.0_loganxx_patched/frameworks/av/media/libstagefright/OMXCodec.cpp	2016-02-25 19:06:50.000000000 +0000
@@ -1338,6 +1338,12 @@
         CHECK_EQ((int)format.eCompressionFormat, (int)OMX_VIDEO_CodingUnused);
 
         int32_t colorFormat;
+		
+		if (!strncmp("OMX.brcm.video.h264.hw.decoder", mComponentName, 30)) {
+			ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] colorFormat BRCM set 19", mComponentName);	
+			format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+		}
+		
         if (meta->findInt32(kKeyColorFormat, &colorFormat)
                 && colorFormat != OMX_COLOR_FormatUnused
                 && colorFormat != format.eColorFormat) {
@@ -1350,6 +1356,10 @@
                 if (format.eColorFormat == colorFormat) {
                     break;
                 }
+				if((unsigned int)err == 0x80001005){
+					ALOGE("PATCH:OMXCodec:setVideoOutputFormat[%s] getParameter(OMX_IndexParamVideoPortFormat) colorFormat(%i) != format.eColorFormat (%i) OMX_ErrorNoMore", mComponentName, colorFormat, format.eColorFormat);
+					err = OMX_ErrorNoMore;
+				}
             }
             if (format.eColorFormat != colorFormat) {
                 CODEC_LOGE("Color format %d is not supported", colorFormat);
@@ -1837,12 +1847,37 @@
             usage |= GRALLOC_USAGE_PRIVATE_NONSECURE;
 #endif
     }
+	
+	ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow def.format.video.eColorFormat = %i", def.format.video.eColorFormat);
+
+	OMX_COLOR_FORMATTYPE HalColorFormat;
+	status_t errss;
+	
+	switch (def.format.video.eColorFormat) {
+		case OMX_COLOR_FormatYCbYCr:
+			ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYCbYCr(%i) -> (%i)", OMX_COLOR_FormatYCbYCr, OMX_COLOR_FormatYUV420Planar);
+			def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+			//errss = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+			//if (errss != OK){
+			//	ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow setParameter failed: %d", errss);
+			//}		
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+		break;
+		case OMX_COLOR_FormatYUV420Planar:
+			ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow OMX_COLOR_FormatYUV420Planar(%i) -> HAL_PIXEL_FORMAT_YV12(%i)", OMX_COLOR_FormatYUV420Planar, (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12);
+			HalColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12;
+		break;
+		default:
+			ALOGE("PATCH:OMXCodec:allocateOutputBuffersFromNativeWindow default(%i) -> default(%i)", def.format.video.eColorFormat, def.format.video.eColorFormat);
+			HalColorFormat = def.format.video.eColorFormat;
+		break;
+	}
 
     err = setNativeWindowSizeFormatAndUsage(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
-            def.format.video.eColorFormat,
+            HalColorFormat,
             rotationDegrees,
             usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP);
     if (err != 0) {
@@ -4499,7 +4534,14 @@
                     caps->mColorFormats.push(flexibleEquivalent);
                 }
             }
-            caps->mColorFormats.push(portFormat.eColorFormat);
+            //caps->mColorFormats.push(portFormat.eColorFormat);
+			if(portFormat.eColorFormat == OMX_COLOR_FormatYCbYCr) {
+				ALOGE("PATCH:OMXCodec:QueryCodec:getParameter(IndexParamVideoPortFormat) portFormat.eColorFormat %i SET %i", portFormat.eColorFormat, OMX_COLOR_FormatYUV420Planar);
+				caps->mColorFormats.push(OMX_COLOR_FormatYUV420Planar);
+			}else{
+				ALOGE("PATCH:OMXCodec:QueryCodec:getParameter(IndexParamVideoPortFormat) DEFAULT portFormat.eColorFormat %i", portFormat.eColorFormat);
+				caps->mColorFormats.push(portFormat.eColorFormat);
+			}
         }
     }
 
diff -ur CM13.0_loganxx/frameworks/base/telephony/java/android/telephony/TelephonyManager.java CM13.0_loganxx_patched/frameworks/base/telephony/java/android/telephony/TelephonyManager.java
--- CM13.0_loganxx/frameworks/base/telephony/java/android/telephony/TelephonyManager.java	2016-02-25 18:17:42.000000000 +0000
+++ CM13.0_loganxx_patched/frameworks/base/telephony/java/android/telephony/TelephonyManager.java	2016-02-25 19:07:39.000000000 +0000
@@ -3301,49 +3301,20 @@
      * @hide
      */
     public static void setTelephonyProperty(int phoneId, String property, String value) {
-        String propVal = "";
-        String p[] = null;
-        String prop = SystemProperties.get(property);
-
-        if (value == null) {
-            value = "";
-        }
-
-        if (prop != null) {
-            p = prop.split(",");
-        }
-
+        
         if (!SubscriptionManager.isValidPhoneId(phoneId)) {
             Rlog.d(TAG, "setTelephonyProperty: invalid phoneId=" + phoneId +
-                    " property=" + property + " value: " + value + " prop=" + prop);
+                    " property=" + property + " value: " + value);
             return;
         }
 
-        for (int i = 0; i < phoneId; i++) {
-            String str = "";
-            if ((p != null) && (i < p.length)) {
-                str = p[i];
-            }
-            propVal = propVal + str + ",";
-        }
-
-        propVal = propVal + value;
-        if (p != null) {
-            for (int i = phoneId + 1; i < p.length; i++) {
-                propVal = propVal + "," + p[i];
-            }
-        }
-
-        if (property.length() > SystemProperties.PROP_NAME_MAX
-                || propVal.length() > SystemProperties.PROP_VALUE_MAX) {
-            Rlog.d(TAG, "setTelephonyProperty: property to long phoneId=" + phoneId +
-                    " property=" + property + " value: " + value + " propVal=" + propVal);
-            return;
+        if (phoneId > 0) {
+            property += "_" + phoneId;
         }
 
         Rlog.d(TAG, "setTelephonyProperty: success phoneId=" + phoneId +
-                " property=" + property + " value: " + value + " propVal=" + propVal);
-        SystemProperties.set(property, propVal);
+                 " property=" + property + " value: " + value);
+        SystemProperties.set(property, value);
     }
 
     /**
@@ -3440,15 +3411,22 @@
      * @hide
      */
     public static String getTelephonyProperty(int phoneId, String property, String defaultVal) {
-        String propVal = null;
-        String prop = SystemProperties.get(property);
-        if ((prop != null) && (prop.length() > 0)) {
-            String values[] = prop.split(",");
-            if ((phoneId >= 0) && (phoneId < values.length) && (values[phoneId] != null)) {
-                propVal = values[phoneId];
-            }
+        if (!SubscriptionManager.isValidPhoneId(phoneId)) {
+            Rlog.d(TAG, "getTelephonyProperty: invalid phoneId=" + phoneId +
+                    " property=" + property);
+            return defaultVal;
         }
-        return propVal == null ? defaultVal : propVal;
+       
+	    if (phoneId > 0) {
+            property += "_" + phoneId;
+        }
+
+        String propVal = SystemProperties.get(property);
+
+        Rlog.d(TAG, "getTelephonyProperty: return propVal='" + propVal + "' phoneId=" + phoneId
+                + " property='" + property + "' defaultVal='" + defaultVal);
+
+        return propVal.isEmpty() ? defaultVal : propVal;
     }
 
     /** @hide */
diff -ur CM13.0_loganxx/frameworks/native/libs/binder/Parcel.cpp CM13.0_loganxx_patched/frameworks/native/libs/binder/Parcel.cpp
--- CM13.0_loganxx/frameworks/native/libs/binder/Parcel.cpp	2016-02-25 18:17:43.000000000 +0000
+++ CM13.0_loganxx_patched/frameworks/native/libs/binder/Parcel.cpp	2016-02-25 19:08:11.000000000 +0000
@@ -859,6 +859,12 @@
     return writeString16(str.string(), str.size());
 }
 
+extern "C" status_t _ZN7android6Parcel13writeString16EPKDsj(void *parcel, const char16_t* str, size_t len);
+
+extern "C" status_t _ZN7android6Parcel13writeString16EPKtj(void *parcel, const char16_t* str, size_t len) {
+    return _ZN7android6Parcel13writeString16EPKDsj(parcel, str, len);
+}
+
 status_t Parcel::writeString16(const char16_t* str, size_t len)
 {
     if (str == NULL) return writeInt32(-1);
diff -ur CM13.0_loganxx/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp CM13.0_loganxx_patched/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
--- CM13.0_loganxx/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2016-02-25 18:17:43.000000000 +0000
+++ CM13.0_loganxx_patched/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2016-02-25 19:08:57.000000000 +0000
@@ -3469,6 +3469,11 @@
 {
     ATRACE_CALL();
 
+	// Rotation artifact problems when useReadPixels is false
+#ifdef HAWAII_HWC
+    useReadPixels = true;
+#endif
+
     // get screen geometry
     uint32_t hw_w = hw->getWidth();
     uint32_t hw_h = hw->getHeight();
diff -ur CM13.0_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java CM13.0_loganxx_patched/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java
--- CM13.0_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2016-02-25 18:17:45.000000000 +0000
+++ CM13.0_loganxx_patched/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2016-02-25 19:09:41.000000000 +0000
@@ -232,6 +232,7 @@
     boolean mDnsCheckDisabled;
     public DcTrackerBase mDcTracker;
     boolean mDoesRilSendMultipleCallRing;
+	boolean mDoesRilSendCallRing;
     int mCallRingContinueToken;
     int mCallRingDelay;
     public boolean mIsTheCurrentActivePhone = true;
@@ -462,6 +463,11 @@
         mDoesRilSendMultipleCallRing = SystemProperties.getBoolean(
                 TelephonyProperties.PROPERTY_RIL_SENDS_MULTIPLE_CALL_RING, true);
         Rlog.d(LOG_TAG, "mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
+		
+		// Some RIL do not even send a single RIL_UNSOL_CALL_RING
+        mDoesRilSendCallRing = SystemProperties.getBoolean(
+                "ro.telephony.call_ring", true);
+        Rlog.d(LOG_TAG, "mDoesRilSendCallRing=" + mDoesRilSendCallRing);
 
         mCallRingDelay = SystemProperties.getInt(
                 TelephonyProperties.PROPERTY_CALL_RING_DELAY, 3000);
@@ -2172,6 +2178,18 @@
     public void notifyNewRingingConnectionP(Connection cn) {
         if (!mIsVoiceCapable)
             return;
+		
+		// Fake RIL_UNSOL_CALL_RING if the RIL doesn't send it.
+        // Note that we need the delay to prevent the request from
+        // being sent after CallTracker detects "RINGING" state, but
+        // before the correct contact-specific ringtone is queried.
+        // Otherwise, the incorrect ringtone will be used
+        if (!mDoesRilSendCallRing) {
+            int token = ++mCallRingContinueToken;
+            sendMessageDelayed(
+                    obtainMessage(EVENT_CALL_RING_CONTINUE, token, 0), mCallRingDelay);
+        }
+		
         AsyncResult ar = new AsyncResult(null, cn, null);
         mNewRingingConnectionRegistrants.notifyRegistrants(ar);
     }
@@ -2767,6 +2785,7 @@
         pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
         pw.println(" mDcTracker=" + mDcTracker);
         pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
+		pw.println(" mDoesRilSendCallRing=" + mDoesRilSendCallRing);
         pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
         pw.println(" mCallRingDelay=" + mCallRingDelay);
         pw.println(" mIsTheCurrentActivePhone=" + mIsTheCurrentActivePhone);
diff -ur CM13.0_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java CM13.0_loganxx_patched/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java
--- CM13.0_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java	2016-02-25 18:17:45.000000000 +0000
+++ CM13.0_loganxx_patched/frameworks/opt/telephony/src/java/com/android/internal/telephony/RIL.java	2016-02-25 19:09:54.000000000 +0000
@@ -303,7 +303,7 @@
     static final int RESPONSE_SOLICITED = 0;
     static final int RESPONSE_UNSOLICITED = 1;
 
-    static final String[] SOCKET_NAME_RIL = {"rild", "rild2", "rild3"};
+    static final String[] SOCKET_NAME_RIL = {"rild", "rild1", "rild2"};
 
     static final int SOCKET_OPEN_RETRY_MILLIS = 4 * 1000;
 
diff -ur CM13.0_loganxx/packages/inputmethods/LatinIME/java/src/com/android/inputmethod/latin/utils/JniUtils.java CM13.0_loganxx_patched/packages/inputmethods/LatinIME/java/src/com/android/inputmethod/latin/utils/JniUtils.java
--- CM13.0_loganxx/packages/inputmethods/LatinIME/java/src/com/android/inputmethod/latin/utils/JniUtils.java	2016-02-25 18:18:04.000000000 +0000
+++ CM13.0_loganxx_patched/packages/inputmethods/LatinIME/java/src/com/android/inputmethod/latin/utils/JniUtils.java	2016-02-25 19:10:47.000000000 +0000
@@ -26,14 +26,10 @@
     public static boolean mHaveGestureLib = false;
     static {
         try {
-            System.loadLibrary(JniLibName.JNI_LIB_NAME2);
+            System.loadLibrary(JniLibName.JNI_LIB_NAME);
             mHaveGestureLib = true;
-        } catch (UnsatisfiedLinkError ue) {
-            try {
-                System.loadLibrary(JniLibName.JNI_LIB_NAME);
-            } catch (UnsatisfiedLinkError ule) {
-                Log.e(TAG, "Could not load native library " + JniLibName.JNI_LIB_NAME, ule);
-            }
+		} catch (UnsatisfiedLinkError ule) {
+            Log.e(TAG, "Could not load native library " + JniLibName.JNI_LIB_NAME, ule);
         }
     }
 
diff -ur CM13.0_loganxx/packages/inputmethods/LatinIME/java-overridable/src/com/android/inputmethod/latin/define/JniLibName.java CM13.0_loganxx_patched/packages/inputmethods/LatinIME/java-overridable/src/com/android/inputmethod/latin/define/JniLibName.java
--- CM13.0_loganxx/packages/inputmethods/LatinIME/java-overridable/src/com/android/inputmethod/latin/define/JniLibName.java	2016-02-25 18:18:04.000000000 +0000
+++ CM13.0_loganxx_patched/packages/inputmethods/LatinIME/java-overridable/src/com/android/inputmethod/latin/define/JniLibName.java	2016-02-25 19:11:33.000000000 +0000
@@ -22,5 +22,4 @@
     }
 
     public static final String JNI_LIB_NAME = "jni_latinime";
-    public static final String JNI_LIB_NAME2 = "jni_latinimegoogle";
-}
+}
\ No newline at end of file
diff -ur CM13.0_loganxx/packages/services/Telephony/res/values/strings.xml CM13.0_loganxx_patched/packages/services/Telephony/res/values/strings.xml
--- CM13.0_loganxx/packages/services/Telephony/res/values/strings.xml	2016-02-25 18:18:06.000000000 +0000
+++ CM13.0_loganxx_patched/packages/services/Telephony/res/values/strings.xml	2016-02-25 19:12:23.000000000 +0000
@@ -632,12 +632,14 @@
     </string-array>
 
     <string-array name="enabled_networks_except_lte_choices" translatable="false">
-        <item>@string/network_3G</item>
-        <item>@string/network_2G</item>
+        <item>@string/preferred_network_mode_wcdma_only_choice</item>
+        <item>@string/preferred_network_mode_gsm_only_choice</item>
+        <item>@string/preferred_network_mode_gsm_wcdma_preferred_choice</item>
     </string-array>
     <string-array name="enabled_networks_except_lte_values" translatable="false">
-        <item>"0"</item>
+        <item>"2"</item>
         <item>"1"</item>
+        <item>"0"</item>
     </string-array>
 
     <string-array name="enabled_networks_except_gsm_lte_choices" translatable="false">
diff -ur CM13.0_loganxx/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java CM13.0_loganxx_patched/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java
--- CM13.0_loganxx/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java	2016-02-25 18:18:06.000000000 +0000
+++ CM13.0_loganxx_patched/packages/services/Telephony/src/com/android/phone/MobileNetworkSettings.java	2016-02-25 19:12:55.000000000 +0000
@@ -1200,7 +1200,7 @@
             case Phone.NT_MODE_WCDMA_ONLY:
                 mButtonEnabledNetworks.setValue(
                         Integer.toString(Phone.NT_MODE_WCDMA_ONLY));
-                mButtonEnabledNetworks.setSummary(R.string.network_wcdma_only);
+                mButtonEnabledNetworks.setSummary(R.string.preferred_network_mode_wcdma_only_choice);
                 break;
             case Phone.NT_MODE_GSM_UMTS:
                 mButtonEnabledNetworks.setValue(
@@ -1210,12 +1210,12 @@
             case Phone.NT_MODE_WCDMA_PREF:
                 mButtonEnabledNetworks.setValue(
                         Integer.toString(Phone.NT_MODE_WCDMA_PREF));
-                mButtonEnabledNetworks.setSummary(R.string.network_wcdma_pref);
+                mButtonEnabledNetworks.setSummary(R.string.preferred_network_mode_gsm_wcdma_preferred_choice);
                 break;
             case Phone.NT_MODE_GSM_ONLY:
                 mButtonEnabledNetworks.setValue(
                         Integer.toString(Phone.NT_MODE_GSM_ONLY));
-                mButtonEnabledNetworks.setSummary(R.string.network_gsm_only);
+                mButtonEnabledNetworks.setSummary(R.string.preferred_network_mode_gsm_only_choice);
                 break;
             case Phone.NT_MODE_LTE_GSM_WCDMA:
                 if (isWorldMode()) {
diff -ur CM13.0_loganxx/system/core/include/utils/RefBase.h CM13.0_loganxx_patched/system/core/include/utils/RefBase.h
--- CM13.0_loganxx/system/core/include/utils/RefBase.h	2016-02-25 18:20:34.000000000 +0000
+++ CM13.0_loganxx_patched/system/core/include/utils/RefBase.h	2016-02-25 19:13:44.000000000 +0000
@@ -53,6 +53,15 @@
 
 // ---------------------------------------------------------------------------
 
+#ifdef REFBASE_JB_MR1_COMPAT_SYMBOLS
+class ReferenceConverterBase {
+public:
+    virtual size_t getReferenceTypeSize() const = 0;
+    virtual void* getReferenceBase(void const*) const = 0;
+    inline virtual ~ReferenceConverterBase() { }
+};
+#endif
+
 class ReferenceRenamer {
 protected:
     // destructor is purposedly not virtual so we avoid code overhead from
diff -ur CM13.0_loganxx/system/core/include/utils/VectorImpl.h CM13.0_loganxx_patched/system/core/include/utils/VectorImpl.h
--- CM13.0_loganxx/system/core/include/utils/VectorImpl.h	2016-02-25 18:20:34.000000000 +0000
+++ CM13.0_loganxx_patched/system/core/include/utils/VectorImpl.h	2016-02-25 19:13:57.000000000 +0000
@@ -105,6 +105,18 @@
     virtual void            do_splat(void* dest, const void* item, size_t num) const = 0;
     virtual void            do_move_forward(void* dest, const void* from, size_t num) const = 0;
     virtual void            do_move_backward(void* dest, const void* from, size_t num) const = 0;
+	
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+    // take care of FBC...
+    virtual void            reservedVectorImpl1();
+    virtual void            reservedVectorImpl2();
+    virtual void            reservedVectorImpl3();
+    virtual void            reservedVectorImpl4();
+    virtual void            reservedVectorImpl5();
+    virtual void            reservedVectorImpl6();
+    virtual void            reservedVectorImpl7();
+    virtual void            reservedVectorImpl8();
+#endif
     
 private:
         void* _grow(size_t where, size_t amount);
@@ -155,6 +167,18 @@
         
 protected:
     virtual int             do_compare(const void* lhs, const void* rhs) const = 0;
+	
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+    // take care of FBC...
+    virtual void            reservedSortedVectorImpl1();
+    virtual void            reservedSortedVectorImpl2();
+    virtual void            reservedSortedVectorImpl3();
+    virtual void            reservedSortedVectorImpl4();
+    virtual void            reservedSortedVectorImpl5();
+    virtual void            reservedSortedVectorImpl6();
+    virtual void            reservedSortedVectorImpl7();
+    virtual void            reservedSortedVectorImpl8();
+#endif	
 
 private:
             ssize_t         _indexOrderOf(const void* item, size_t* order = 0) const;
diff -ur CM13.0_loganxx/system/core/init/init.cpp CM13.0_loganxx_patched/system/core/init/init.cpp
--- CM13.0_loganxx/system/core/init/init.cpp	2016-02-25 18:20:34.000000000 +0000
+++ CM13.0_loganxx_patched/system/core/init/init.cpp	2016-02-25 19:14:27.000000000 +0000
@@ -75,6 +75,9 @@
 #define BOARD_CHARGING_CMDLINE_VALUE "true"
 #endif
 
+static char hardware[32];
+static unsigned revision = 0;
+
 static char qemu[32];
 static char battchg_pause[32];
 
@@ -806,27 +809,39 @@
 }
 
 static void export_kernel_boot_props() {
+	
+	char tmp[PROP_VALUE_MAX];
+    int ret;
+	
     struct {
         const char *src_prop;
         const char *dst_prop;
         const char *default_value;
     } prop_map[] = {
-#ifndef IGNORE_RO_BOOT_SERIALNO
-        { "ro.boot.serialno",   "ro.serialno",   "", },
-#endif
-        { "ro.boot.mode",       "ro.bootmode",   "unknown", },
+		{ "ro.boot.mode",       "ro.bootmode",   "unknown", },
         { "ro.boot.baseband",   "ro.baseband",   "unknown", },
         { "ro.boot.bootloader", "ro.bootloader", "unknown", },
-        { "ro.boot.hardware",   "ro.hardware",   "unknown", },
-#ifndef IGNORE_RO_BOOT_REVISION
-        { "ro.boot.revision",   "ro.revision",   "0", },
-#endif
     };
     for (size_t i = 0; i < ARRAY_SIZE(prop_map); i++) {
         char value[PROP_VALUE_MAX];
         int rc = property_get(prop_map[i].src_prop, value);
         property_set(prop_map[i].dst_prop, (rc > 0) ? value : prop_map[i].default_value);
     }
+	
+	get_hardware_name(hardware, &revision);
+
+   /* if this was given on kernel command line, override what we read
+    * before (e.g. from /proc/cpuinfo), if anything */
+    ret = property_get("ro.boot.hardware", tmp);
+    if (ret)
+        strlcpy(hardware, tmp, sizeof(hardware));
+    property_set("ro.hardware", hardware);
+
+    ret = property_get("ro.boot.revision", tmp);
+    if (!ret)
+        snprintf(tmp, PROP_VALUE_MAX, "%d", revision);
+    property_set("ro.revision", tmp);
+	
 }
 
 static void process_kernel_dt(void)
diff -ur CM13.0_loganxx/system/core/init/util.cpp CM13.0_loganxx_patched/system/core/init/util.cpp
--- CM13.0_loganxx/system/core/init/util.cpp	2016-02-25 18:20:34.000000000 +0000
+++ CM13.0_loganxx_patched/system/core/init/util.cpp	2016-02-25 19:14:37.000000000 +0000
@@ -401,6 +401,34 @@
     }
 }
 
+void get_hardware_name(char *hardware, unsigned int *revision) {
+  FILE* fp = fopen("/proc/cpuinfo", "re");
+  if (fp == NULL) {
+    return;
+  }
+  char buf[1024];
+  while (fgets(buf, sizeof(buf), fp) != NULL) {
+    if (strncmp(buf, "Hardware", 8) == 0) {
+      const char* hw = strstr(buf, ": ");
+      if (hw) {
+        hw += 2;
+        size_t n = 0;
+        while (*hw) {
+          if (!isspace(*hw)) {
+            hardware[n++] = tolower(*hw);
+          }
+          hw++;
+          if (n == 31) break;
+        }
+        hardware[n] = 0;
+      }
+    } else if (strncmp(buf, "Revision", 8) == 0) {
+      sscanf(buf, "Revision : %ux", revision);
+    }
+  }
+  fclose(fp);
+}
+
 void import_kernel_cmdline(bool in_qemu, std::function<void(char*,bool)> import_kernel_nv)
 {
     char cmdline[2048];
diff -ur CM13.0_loganxx/system/core/init/util.h CM13.0_loganxx_patched/system/core/init/util.h
--- CM13.0_loganxx/system/core/init/util.h	2016-02-25 18:20:34.000000000 +0000
+++ CM13.0_loganxx_patched/system/core/init/util.h	2016-02-25 19:14:48.000000000 +0000
@@ -58,6 +58,7 @@
 void remove_link(const char *oldpath, const char *newpath);
 int wait_for_file(const char *filename, int timeout);
 void open_devnull_stdio(void);
+void get_hardware_name(char *hardware, unsigned int *revision);
 void import_kernel_cmdline(bool in_qemu, std::function<void(char*,bool)>);
 int make_dir(const char *path, mode_t mode);
 int restorecon(const char *pathname);
diff -ur CM13.0_loganxx/system/core/libnetutils/ifc_utils.c CM13.0_loganxx_patched/system/core/libnetutils/ifc_utils.c
--- CM13.0_loganxx/system/core/libnetutils/ifc_utils.c	2016-02-25 18:20:34.000000000 +0000
+++ CM13.0_loganxx_patched/system/core/libnetutils/ifc_utils.c	2016-02-17 20:27:58.000000000 +0000
@@ -703,3 +703,19 @@
 
     return 0;
 }
+
+// Required for Broadcom RILD
+int ifc_set_mtu(const char *name, int mtuSz)
+{
+    struct ifreq ifr;
+    int ret;
+    ifc_init_ifr(name, &ifr);
+    ifr.ifr_mtu = mtuSz;
+
+    ret = ioctl(ifc_ctl_sock, SIOCSIFMTU, &ifr);
+    if (ret < 0) {
+        printerr("ifc_set_mtu: SIOCSIFMTU failed: %d\n", ret);
+    }
+
+    return ret;
+}
diff -ur CM13.0_loganxx/system/core/libutils/RefBase.cpp CM13.0_loganxx_patched/system/core/libutils/RefBase.cpp
--- CM13.0_loganxx/system/core/libutils/RefBase.cpp	2016-02-25 18:20:34.000000000 +0000
+++ CM13.0_loganxx_patched/system/core/libutils/RefBase.cpp	2016-02-25 19:15:27.000000000 +0000
@@ -630,6 +630,13 @@
 
 // ---------------------------------------------------------------------------
 
+#ifdef REFBASE_JB_MR1_COMPAT_SYMBOLS
+extern "C" void _ZN7android7RefBase14moveReferencesEPvPKvjRKNS_22ReferenceConverterBaseE(void* /*dst*/, void const* /*src*/, size_t /*n*/,
+        const ReferenceConverterBase& /*caster*/)
+{
+}
+#endif
+
 #if DEBUG_REFS
 void RefBase::renameRefs(size_t n, const ReferenceRenamer& renamer) {
     for (size_t i=0 ; i<n ; i++) {
diff -ur CM13.0_loganxx/system/core/libutils/VectorImpl.cpp CM13.0_loganxx_patched/system/core/libutils/VectorImpl.cpp
--- CM13.0_loganxx/system/core/libutils/VectorImpl.cpp	2016-02-25 18:20:34.000000000 +0000
+++ CM13.0_loganxx_patched/system/core/libutils/VectorImpl.cpp	2016-02-25 19:15:40.000000000 +0000
@@ -552,6 +552,17 @@
     do_move_backward(dest, from, num);
 }
 
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+void VectorImpl::reservedVectorImpl1() { }
+void VectorImpl::reservedVectorImpl2() { }
+void VectorImpl::reservedVectorImpl3() { }
+void VectorImpl::reservedVectorImpl4() { }
+void VectorImpl::reservedVectorImpl5() { }
+void VectorImpl::reservedVectorImpl6() { }
+void VectorImpl::reservedVectorImpl7() { }
+void VectorImpl::reservedVectorImpl8() { }
+#endif
+
 /*****************************************************************************/
 
 SortedVectorImpl::SortedVectorImpl(size_t itemSize, uint32_t flags)
@@ -667,6 +678,17 @@
     return i;
 }
 
+#ifdef NEEDS_VECTORIMPL_SYMBOLS
+void SortedVectorImpl::reservedSortedVectorImpl1() { };
+void SortedVectorImpl::reservedSortedVectorImpl2() { };
+void SortedVectorImpl::reservedSortedVectorImpl3() { };
+void SortedVectorImpl::reservedSortedVectorImpl4() { };
+void SortedVectorImpl::reservedSortedVectorImpl5() { };
+void SortedVectorImpl::reservedSortedVectorImpl6() { };
+void SortedVectorImpl::reservedSortedVectorImpl7() { };
+void SortedVectorImpl::reservedSortedVectorImpl8() { };
+#endif
+
 /*****************************************************************************/
 
 }; // namespace android
